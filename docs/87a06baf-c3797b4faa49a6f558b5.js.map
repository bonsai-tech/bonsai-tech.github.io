{"version":3,"file":"87a06baf-c3797b4faa49a6f558b5.js","mappings":"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","sources":["webpack://bonsai-web/./node_modules/@babylonjs/core/Meshes/mesh.js"],"sourcesContent":["import { Observable } from \"../Misc/observable.js\";\nimport { Tools, AsyncLoop } from \"../Misc/tools.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { runCoroutineSync, runCoroutineAsync, createYieldingScheduler } from \"../Misc/coroutine.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { ScenePerformancePriority } from \"../scene.js\";\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"./mesh.vertexData.js\";\nimport { Geometry } from \"./geometry.js\";\nimport { AbstractMesh } from \"./abstractMesh.js\";\nimport { SubMesh } from \"./subMesh.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags.js\";\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { GetClass, RegisterClass } from \"../Misc/typeStore.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { MeshLODLevel } from \"./meshLODLevel.js\";\n/**\n * @internal\n **/\nexport class _CreationDataStorage {}\n/**\n * @internal\n **/\nclass _InstanceDataStorage {\n  constructor() {\n    this.visibleInstances = {};\n    this.batchCache = new _InstancesBatch();\n    this.batchCacheReplacementModeInFrozenMode = new _InstancesBatch();\n    this.instancesBufferSize = 32 * 16 * 4; // let's start with a maximum of 32 instances\n  }\n}\n/**\n * @internal\n **/\nexport class _InstancesBatch {\n  constructor() {\n    this.mustReturn = false;\n    this.visibleInstances = new Array();\n    this.renderSelf = new Array();\n    this.hardwareInstancedRendering = new Array();\n  }\n}\n/**\n * @internal\n **/\nclass _ThinInstanceDataStorage {\n  constructor() {\n    this.instancesCount = 0;\n    this.matrixBuffer = null;\n    this.previousMatrixBuffer = null;\n    this.matrixBufferSize = 32 * 16; // let's start with a maximum of 32 thin instances\n    this.matrixData = null;\n    this.boundingVectors = [];\n    this.worldMatrices = null;\n  }\n}\n/**\n * @internal\n **/\nclass _InternalMeshDataInfo {\n  constructor() {\n    this._areNormalsFrozen = false; // Will be used by ribbons mainly\n    // Will be used to save a source mesh reference, If any\n    this._source = null;\n    // Will be used to for fast cloned mesh lookup\n    this.meshMap = null;\n    this._preActivateId = -1;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this._LODLevels = new Array();\n    /** Alternative definition of LOD level, using screen coverage instead of distance */\n    this._useLODScreenCoverage = false;\n    this._effectiveMaterial = null;\n    this._forcedInstanceCount = 0;\n  }\n}\n/**\n * Class used to represent renderable models\n */\nexport class Mesh extends AbstractMesh {\n  /**\n   * Gets the default side orientation.\n   * @param orientation the orientation to value to attempt to get\n   * @returns the default orientation\n   * @internal\n   */\n  static _GetDefaultSideOrientation(orientation) {\n    return orientation || Mesh.FRONTSIDE; // works as Mesh.FRONTSIDE is 0\n  }\n  /**\n   * Determines if the LOD levels are intended to be calculated using screen coverage (surface area ratio) instead of distance.\n   */\n  get useLODScreenCoverage() {\n    return this._internalMeshDataInfo._useLODScreenCoverage;\n  }\n  set useLODScreenCoverage(value) {\n    this._internalMeshDataInfo._useLODScreenCoverage = value;\n    this._sortLODLevels();\n  }\n  get computeBonesUsingShaders() {\n    return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\n  }\n  set computeBonesUsingShaders(value) {\n    if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\n      return;\n    }\n    if (value && this._internalMeshDataInfo._sourcePositions) {\n      // switch from software to GPU computation: we need to reset the vertex and normal buffers that have been updated by the software process\n      this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions, true);\n      if (this._internalMeshDataInfo._sourceNormals) {\n        this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals, true);\n      }\n      this._internalMeshDataInfo._sourcePositions = null;\n      this._internalMeshDataInfo._sourceNormals = null;\n    }\n    this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\n    this._markSubMeshesAsAttributesDirty();\n  }\n  /**\n   * An event triggered before rendering the mesh\n   */\n  get onBeforeRenderObservable() {\n    if (!this._internalMeshDataInfo._onBeforeRenderObservable) {\n      this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();\n    }\n    return this._internalMeshDataInfo._onBeforeRenderObservable;\n  }\n  /**\n   * An event triggered before binding the mesh\n   */\n  get onBeforeBindObservable() {\n    if (!this._internalMeshDataInfo._onBeforeBindObservable) {\n      this._internalMeshDataInfo._onBeforeBindObservable = new Observable();\n    }\n    return this._internalMeshDataInfo._onBeforeBindObservable;\n  }\n  /**\n   * An event triggered after rendering the mesh\n   */\n  get onAfterRenderObservable() {\n    if (!this._internalMeshDataInfo._onAfterRenderObservable) {\n      this._internalMeshDataInfo._onAfterRenderObservable = new Observable();\n    }\n    return this._internalMeshDataInfo._onAfterRenderObservable;\n  }\n  /**\n   * An event triggeredbetween rendering pass when using separateCullingPass = true\n   */\n  get onBetweenPassObservable() {\n    if (!this._internalMeshDataInfo._onBetweenPassObservable) {\n      this._internalMeshDataInfo._onBetweenPassObservable = new Observable();\n    }\n    return this._internalMeshDataInfo._onBetweenPassObservable;\n  }\n  /**\n   * An event triggered before drawing the mesh\n   */\n  get onBeforeDrawObservable() {\n    if (!this._internalMeshDataInfo._onBeforeDrawObservable) {\n      this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();\n    }\n    return this._internalMeshDataInfo._onBeforeDrawObservable;\n  }\n  /**\n   * Sets a callback to call before drawing the mesh. It is recommended to use onBeforeDrawObservable instead\n   */\n  set onBeforeDraw(callback) {\n    if (this._onBeforeDrawObserver) {\n      this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);\n    }\n    this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);\n  }\n  get hasInstances() {\n    return this.instances.length > 0;\n  }\n  get hasThinInstances() {\n    var _a;\n    return ((_a = this._thinInstanceDataStorage.instancesCount) !== null && _a !== void 0 ? _a : 0) > 0;\n  }\n  /**\n   * Gets or sets the forced number of instances to display.\n   * If 0 (default value), the number of instances is not forced and depends on the draw type\n   * (regular / instance / thin instances mesh)\n   */\n  get forcedInstanceCount() {\n    return this._internalMeshDataInfo._forcedInstanceCount;\n  }\n  set forcedInstanceCount(count) {\n    this._internalMeshDataInfo._forcedInstanceCount = count;\n  }\n  /**\n   * Gets the source mesh (the one used to clone this one from)\n   */\n  get source() {\n    return this._internalMeshDataInfo._source;\n  }\n  /**\n   * Gets the list of clones of this mesh\n   * The scene must have been constructed with useClonedMeshMap=true for this to work!\n   * Note that useClonedMeshMap=true is the default setting\n   */\n  get cloneMeshMap() {\n    return this._internalMeshDataInfo.meshMap;\n  }\n  /**\n   * Gets or sets a boolean indicating that this mesh does not use index buffer\n   */\n  get isUnIndexed() {\n    return this._unIndexed;\n  }\n  set isUnIndexed(value) {\n    if (this._unIndexed !== value) {\n      this._unIndexed = value;\n      this._markSubMeshesAsAttributesDirty();\n    }\n  }\n  /** Gets the array buffer used to store the instanced buffer used for instances' world matrices */\n  get worldMatrixInstancedBuffer() {\n    return this._instanceDataStorage.instancesData;\n  }\n  /** Gets the array buffer used to store the instanced buffer used for instances' previous world matrices */\n  get previousWorldMatrixInstancedBuffer() {\n    return this._instanceDataStorage.instancesPreviousData;\n  }\n  /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\n  get manualUpdateOfWorldMatrixInstancedBuffer() {\n    return this._instanceDataStorage.manualUpdate;\n  }\n  set manualUpdateOfWorldMatrixInstancedBuffer(value) {\n    this._instanceDataStorage.manualUpdate = value;\n  }\n  /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\n  get manualUpdateOfPreviousWorldMatrixInstancedBuffer() {\n    return this._instanceDataStorage.previousManualUpdate;\n  }\n  set manualUpdateOfPreviousWorldMatrixInstancedBuffer(value) {\n    this._instanceDataStorage.previousManualUpdate = value;\n  }\n  /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices must be performed in all cases (and notably even in frozen mode) */\n  get forceWorldMatrixInstancedBufferUpdate() {\n    return this._instanceDataStorage.forceMatrixUpdates;\n  }\n  set forceWorldMatrixInstancedBufferUpdate(value) {\n    this._instanceDataStorage.forceMatrixUpdates = value;\n  }\n  /**\n   * @constructor\n   * @param name The value used by scene.getMeshByName() to do a lookup.\n   * @param scene The scene to add this mesh to.\n   * @param parent The parent of this mesh, if it has one\n   * @param source An optional Mesh from which geometry is shared, cloned.\n   * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\n   *                  When false, achieved by calling a clone(), also passing False.\n   *                  This will make creation of children, recursive.\n   * @param clonePhysicsImpostor When cloning, include cloning mesh physics impostor, default True.\n   */\n  constructor(name) {\n    let scene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let doNotCloneChildren = arguments.length > 4 ? arguments[4] : undefined;\n    let clonePhysicsImpostor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    super(name, scene);\n    // Internal data\n    this._internalMeshDataInfo = new _InternalMeshDataInfo();\n    // Members\n    /**\n     * Gets the delay loading state of the mesh (when delay loading is turned on)\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/incrementalLoading\n     */\n    this.delayLoadState = 0;\n    /**\n     * Gets the list of instances created from this mesh\n     * it is not supposed to be modified manually.\n     * Note also that the order of the InstancedMesh wihin the array is not significant and might change.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\n     */\n    this.instances = new Array();\n    // Private\n    /** @internal */\n    this._creationDataStorage = null;\n    /** @internal */\n    this._geometry = null;\n    /** @internal */\n    this._instanceDataStorage = new _InstanceDataStorage();\n    /** @internal */\n    this._thinInstanceDataStorage = new _ThinInstanceDataStorage();\n    /** @internal */\n    this._shouldGenerateFlatShading = false;\n    // Use by builder only to know what orientation were the mesh build in.\n    /** @internal */\n    this._originalBuilderSideOrientation = Mesh.DEFAULTSIDE;\n    /**\n     * Use this property to change the original side orientation defined at construction time\n     */\n    this.overrideMaterialSideOrientation = null;\n    /**\n     * Gets or sets a boolean indicating whether to render ignoring the active camera's max z setting. (false by default)\n     * Note this will reduce performance when set to true.\n     */\n    this.ignoreCameraMaxZ = false;\n    scene = this.getScene();\n    this._onBeforeDraw = (isInstance, world, effectiveMaterial) => {\n      if (isInstance && effectiveMaterial) {\n        if (this._uniformBuffer) {\n          this.transferToEffect(world);\n        } else {\n          effectiveMaterial.bindOnlyWorldMatrix(world);\n        }\n      }\n    };\n    if (source) {\n      // Geometry\n      if (source._geometry) {\n        source._geometry.applyToMesh(this);\n      }\n      // Deep copy\n      DeepCopier.DeepCopy(source, this, [\"name\", \"material\", \"skeleton\", \"instances\", \"parent\", \"uniqueId\", \"source\", \"metadata\", \"morphTargetManager\", \"hasInstances\", \"worldMatrixInstancedBuffer\", \"previousWorldMatrixInstancedBuffer\", \"hasLODLevels\", \"geometry\", \"isBlocked\", \"areNormalsFrozen\", \"facetNb\", \"isFacetDataEnabled\", \"lightSources\", \"useBones\", \"isAnInstance\", \"collider\", \"edgesRenderer\", \"forward\", \"up\", \"right\", \"absolutePosition\", \"absoluteScaling\", \"absoluteRotationQuaternion\", \"isWorldMatrixFrozen\", \"nonUniformScaling\", \"behaviors\", \"worldMatrixFromCache\", \"hasThinInstances\", \"cloneMeshMap\", \"hasBoundingInfo\"], [\"_poseMatrix\"]);\n      // Source mesh\n      this._internalMeshDataInfo._source = source;\n      if (scene.useClonedMeshMap) {\n        if (!source._internalMeshDataInfo.meshMap) {\n          source._internalMeshDataInfo.meshMap = {};\n        }\n        source._internalMeshDataInfo.meshMap[this.uniqueId] = this;\n      }\n      // Construction Params\n      // Clone parameters allowing mesh to be updated in case of parametric shapes.\n      this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;\n      this._creationDataStorage = source._creationDataStorage;\n      // Animation ranges\n      if (source._ranges) {\n        const ranges = source._ranges;\n        for (const name in ranges) {\n          if (!Object.prototype.hasOwnProperty.call(ranges, name)) {\n            continue;\n          }\n          if (!ranges[name]) {\n            continue;\n          }\n          this.createAnimationRange(name, ranges[name].from, ranges[name].to);\n        }\n      }\n      // Metadata\n      if (source.metadata && source.metadata.clone) {\n        this.metadata = source.metadata.clone();\n      } else {\n        this.metadata = source.metadata;\n      }\n      this._internalMetadata = source._internalMetadata;\n      // Tags\n      if (Tags && Tags.HasTags(source)) {\n        Tags.AddTagsTo(this, Tags.GetTags(source, true));\n      }\n      // Enabled. We shouldn't need to check the source's ancestors, as this mesh\n      // will have the same ones.\n      this.setEnabled(source.isEnabled(false));\n      // Parent\n      this.parent = source.parent;\n      // Pivot\n      this.setPivotMatrix(source.getPivotMatrix());\n      this.id = name + \".\" + source.id;\n      // Material\n      this.material = source.material;\n      if (!doNotCloneChildren) {\n        // Children\n        const directDescendants = source.getDescendants(true);\n        for (let index = 0; index < directDescendants.length; index++) {\n          const child = directDescendants[index];\n          if (child.clone) {\n            child.clone(name + \".\" + child.name, this);\n          }\n        }\n      }\n      // Morphs\n      if (source.morphTargetManager) {\n        this.morphTargetManager = source.morphTargetManager;\n      }\n      // Physics clone\n      if (scene.getPhysicsEngine) {\n        const physicsEngine = scene.getPhysicsEngine();\n        if (clonePhysicsImpostor && physicsEngine) {\n          if (physicsEngine.getPluginVersion() === 1) {\n            const impostor = physicsEngine.getImpostorForPhysicsObject(source);\n            if (impostor) {\n              this.physicsImpostor = impostor.clone(this);\n            }\n          } else if (physicsEngine.getPluginVersion() === 2) {\n            if (source.physicsBody) {\n              source.physicsBody.clone(this);\n            }\n          }\n        }\n      }\n      // Particles\n      for (let index = 0; index < scene.particleSystems.length; index++) {\n        const system = scene.particleSystems[index];\n        if (system.emitter === source) {\n          system.clone(system.name, this);\n        }\n      }\n      // Skeleton\n      this.skeleton = source.skeleton;\n      this.refreshBoundingInfo(true, true);\n      this.computeWorldMatrix(true);\n    }\n    // Parent\n    if (parent !== null) {\n      this.parent = parent;\n    }\n    this._instanceDataStorage.hardwareInstancedRendering = this.getEngine().getCaps().instancedArrays;\n    this._internalMeshDataInfo._onMeshReadyObserverAdded = observer => {\n      // only notify once! then unregister the observer\n      observer.unregisterOnNextCall = true;\n      if (this.isReady(true)) {\n        this.onMeshReadyObservable.notifyObservers(this);\n      } else {\n        if (!this._internalMeshDataInfo._checkReadinessObserver) {\n          this._internalMeshDataInfo._checkReadinessObserver = this._scene.onBeforeRenderObservable.add(() => {\n            // check for complete readiness\n            if (this.isReady(true)) {\n              this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);\n              this._internalMeshDataInfo._checkReadinessObserver = null;\n              this.onMeshReadyObservable.notifyObservers(this);\n            }\n          });\n        }\n      }\n    };\n    this.onMeshReadyObservable = new Observable(this._internalMeshDataInfo._onMeshReadyObserverAdded);\n    if (source) {\n      source.onClonedObservable.notifyObservers(this);\n    }\n  }\n  instantiateHierarchy() {\n    let newParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    let onNewNodeCreated = arguments.length > 2 ? arguments[2] : undefined;\n    const instance = this.getTotalVertices() === 0 || options && options.doNotInstantiate && (options.doNotInstantiate === true || options.doNotInstantiate(this)) ? this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true) : this.createInstance(\"instance of \" + (this.name || this.id));\n    instance.parent = newParent || this.parent;\n    instance.position = this.position.clone();\n    instance.scaling = this.scaling.clone();\n    if (this.rotationQuaternion) {\n      instance.rotationQuaternion = this.rotationQuaternion.clone();\n    } else {\n      instance.rotation = this.rotation.clone();\n    }\n    if (onNewNodeCreated) {\n      onNewNodeCreated(this, instance);\n    }\n    for (const child of this.getChildTransformNodes(true)) {\n      // instancedMesh should have a different sourced mesh\n      if (child.getClassName() === \"InstancedMesh\" && instance.getClassName() === \"Mesh\" && child.sourceMesh === this) {\n        child.instantiateHierarchy(instance, {\n          doNotInstantiate: options && options.doNotInstantiate || false,\n          newSourcedMesh: instance\n        }, onNewNodeCreated);\n      } else {\n        child.instantiateHierarchy(instance, options, onNewNodeCreated);\n      }\n    }\n    return instance;\n  }\n  /**\n   * Gets the class name\n   * @returns the string \"Mesh\".\n   */\n  getClassName() {\n    return \"Mesh\";\n  }\n  /** @internal */\n  get _isMesh() {\n    return true;\n  }\n  /**\n   * Returns a description of this mesh\n   * @param fullDetails define if full details about this mesh must be used\n   * @returns a descriptive string representing this mesh\n   */\n  toString(fullDetails) {\n    let ret = super.toString(fullDetails);\n    ret += \", n vertices: \" + this.getTotalVertices();\n    ret += \", parent: \" + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : \"NONE\");\n    if (this.animations) {\n      for (let i = 0; i < this.animations.length; i++) {\n        ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n      }\n    }\n    if (fullDetails) {\n      if (this._geometry) {\n        const ib = this.getIndices();\n        const vb = this.getVerticesData(VertexBuffer.PositionKind);\n        if (vb && ib) {\n          ret += \", flat shading: \" + (vb.length / 3 === ib.length ? \"YES\" : \"NO\");\n        }\n      } else {\n        ret += \", flat shading: UNKNOWN\";\n      }\n    }\n    return ret;\n  }\n  /** @internal */\n  _unBindEffect() {\n    super._unBindEffect();\n    for (const instance of this.instances) {\n      instance._unBindEffect();\n    }\n  }\n  /**\n   * Gets a boolean indicating if this mesh has LOD\n   */\n  get hasLODLevels() {\n    return this._internalMeshDataInfo._LODLevels.length > 0;\n  }\n  /**\n   * Gets the list of MeshLODLevel associated with the current mesh\n   * @returns an array of MeshLODLevel\n   */\n  getLODLevels() {\n    return this._internalMeshDataInfo._LODLevels;\n  }\n  _sortLODLevels() {\n    const sortingOrderFactor = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;\n    this._internalMeshDataInfo._LODLevels.sort((a, b) => {\n      if (a.distanceOrScreenCoverage < b.distanceOrScreenCoverage) {\n        return sortingOrderFactor;\n      }\n      if (a.distanceOrScreenCoverage > b.distanceOrScreenCoverage) {\n        return -sortingOrderFactor;\n      }\n      return 0;\n    });\n  }\n  /**\n   * Add a mesh as LOD level triggered at the given distance.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n   * @param distanceOrScreenCoverage Either distance from the center of the object to show this level or the screen coverage if `useScreenCoverage` is set to `true`.\n   * If screen coverage, value is a fraction of the screen's total surface, between 0 and 1.\n   * Example Playground for distance https://playground.babylonjs.com/#QE7KM#197\n   * Example Playground for screen coverage https://playground.babylonjs.com/#QE7KM#196\n   * @param mesh The mesh to be added as LOD level (can be null)\n   * @returns This mesh (for chaining)\n   */\n  addLODLevel(distanceOrScreenCoverage, mesh) {\n    if (mesh && mesh._masterMesh) {\n      Logger.Warn(\"You cannot use a mesh as LOD level twice\");\n      return this;\n    }\n    const level = new MeshLODLevel(distanceOrScreenCoverage, mesh);\n    this._internalMeshDataInfo._LODLevels.push(level);\n    if (mesh) {\n      mesh._masterMesh = this;\n    }\n    this._sortLODLevels();\n    return this;\n  }\n  /**\n   * Returns the LOD level mesh at the passed distance or null if not found.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n   * @param distance The distance from the center of the object to show this level\n   * @returns a Mesh or `null`\n   */\n  getLODLevelAtDistance(distance) {\n    const internalDataInfo = this._internalMeshDataInfo;\n    for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {\n      const level = internalDataInfo._LODLevels[index];\n      if (level.distanceOrScreenCoverage === distance) {\n        return level.mesh;\n      }\n    }\n    return null;\n  }\n  /**\n   * Remove a mesh from the LOD array\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n   * @param mesh defines the mesh to be removed\n   * @returns This mesh (for chaining)\n   */\n  removeLODLevel(mesh) {\n    const internalDataInfo = this._internalMeshDataInfo;\n    for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {\n      if (internalDataInfo._LODLevels[index].mesh === mesh) {\n        internalDataInfo._LODLevels.splice(index, 1);\n        if (mesh) {\n          mesh._masterMesh = null;\n        }\n      }\n    }\n    this._sortLODLevels();\n    return this;\n  }\n  /**\n   * Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/LOD\n   * @param camera defines the camera to use to compute distance\n   * @param boundingSphere defines a custom bounding sphere to use instead of the one from this mesh\n   * @returns This mesh (for chaining)\n   */\n  getLOD(camera, boundingSphere) {\n    const internalDataInfo = this._internalMeshDataInfo;\n    if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {\n      return this;\n    }\n    const bSphere = boundingSphere || this.getBoundingInfo().boundingSphere;\n    const distanceToCamera = camera.mode === Camera.ORTHOGRAPHIC_CAMERA ? camera.minZ : bSphere.centerWorld.subtract(camera.globalPosition).length();\n    let compareValue = distanceToCamera;\n    let compareSign = 1;\n    if (internalDataInfo._useLODScreenCoverage) {\n      const screenArea = camera.screenArea;\n      let meshArea = bSphere.radiusWorld * camera.minZ / distanceToCamera;\n      meshArea = meshArea * meshArea * Math.PI;\n      compareValue = meshArea / screenArea;\n      compareSign = -1;\n    }\n    if (compareSign * internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distanceOrScreenCoverage > compareSign * compareValue) {\n      if (this.onLODLevelSelection) {\n        this.onLODLevelSelection(compareValue, this, this);\n      }\n      return this;\n    }\n    for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {\n      const level = internalDataInfo._LODLevels[index];\n      if (compareSign * level.distanceOrScreenCoverage < compareSign * compareValue) {\n        if (level.mesh) {\n          if (level.mesh.delayLoadState === 4) {\n            level.mesh._checkDelayState();\n            return this;\n          }\n          if (level.mesh.delayLoadState === 2) {\n            return this;\n          }\n          level.mesh._preActivate();\n          level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n        }\n        if (this.onLODLevelSelection) {\n          this.onLODLevelSelection(compareValue, this, level.mesh);\n        }\n        return level.mesh;\n      }\n    }\n    if (this.onLODLevelSelection) {\n      this.onLODLevelSelection(compareValue, this, this);\n    }\n    return this;\n  }\n  /**\n   * Gets the mesh internal Geometry object\n   */\n  get geometry() {\n    return this._geometry;\n  }\n  /**\n   * Returns the total number of vertices within the mesh geometry or zero if the mesh has no geometry.\n   * @returns the total number of vertices\n   */\n  getTotalVertices() {\n    if (this._geometry === null || this._geometry === undefined) {\n      return 0;\n    }\n    return this._geometry.getTotalVertices();\n  }\n  /**\n   * Returns the content of an associated vertex buffer\n   * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param copyWhenShared defines a boolean indicating that if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one\n   * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\n   * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n   * @returns a FloatArray or null if the mesh has no geometry or no vertex buffer for this kind.\n   */\n  getVerticesData(kind, copyWhenShared, forceCopy, bypassInstanceData) {\n    var _a, _b;\n    if (!this._geometry) {\n      return null;\n    }\n    let data = bypassInstanceData ? undefined : (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.getFloatData(this.instances.length + 1,\n    // +1 because the master mesh is not included in the instances array\n    forceCopy || copyWhenShared && this._geometry.meshes.length !== 1);\n    if (!data) {\n      data = this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);\n    }\n    return data;\n  }\n  /**\n   * Returns the mesh VertexBuffer object from the requested `kind`\n   * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.NormalKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n   * @returns a FloatArray or null if the mesh has no vertex buffer for this kind.\n   */\n  getVertexBuffer(kind, bypassInstanceData) {\n    var _a, _b;\n    if (!this._geometry) {\n      return null;\n    }\n    return (_b = bypassInstanceData ? undefined : (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== null && _b !== void 0 ? _b : this._geometry.getVertexBuffer(kind);\n  }\n  /**\n   * Tests if a specific vertex buffer is associated with this mesh\n   * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.NormalKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n   * @returns a boolean\n   */\n  isVerticesDataPresent(kind, bypassInstanceData) {\n    var _a;\n    if (!this._geometry) {\n      if (this._delayInfo) {\n        return this._delayInfo.indexOf(kind) !== -1;\n      }\n      return false;\n    }\n    return !bypassInstanceData && ((_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== undefined || this._geometry.isVerticesDataPresent(kind);\n  }\n  /**\n   * Returns a boolean defining if the vertex data for the requested `kind` is updatable.\n   * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n   * @returns a boolean\n   */\n  isVertexBufferUpdatable(kind, bypassInstanceData) {\n    var _a;\n    if (!this._geometry) {\n      if (this._delayInfo) {\n        return this._delayInfo.indexOf(kind) !== -1;\n      }\n      return false;\n    }\n    if (!bypassInstanceData) {\n      const buffer = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind];\n      if (buffer) {\n        return buffer.isUpdatable();\n      }\n    }\n    return this._geometry.isVertexBufferUpdatable(kind);\n  }\n  /**\n   * Returns a string which contains the list of existing `kinds` of Vertex Data associated with this mesh.\n   * @param bypassInstanceData defines a boolean indicating that the function should not take into account the instance data (applies only if the mesh has instances). Default: false\n   * @returns an array of strings\n   */\n  getVerticesDataKinds(bypassInstanceData) {\n    if (!this._geometry) {\n      const result = new Array();\n      if (this._delayInfo) {\n        this._delayInfo.forEach(function (kind) {\n          result.push(kind);\n        });\n      }\n      return result;\n    }\n    const kinds = this._geometry.getVerticesDataKinds();\n    if (!bypassInstanceData && this._userInstancedBuffersStorage) {\n      for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {\n        if (kinds.indexOf(kind) === -1) {\n          kinds.push(kind);\n        }\n      }\n    }\n    return kinds;\n  }\n  /**\n   * Returns a positive integer : the total number of indices in this mesh geometry.\n   * @returns the numner of indices or zero if the mesh has no geometry.\n   */\n  getTotalIndices() {\n    if (!this._geometry) {\n      return 0;\n    }\n    return this._geometry.getTotalIndices();\n  }\n  /**\n   * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\n   * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns the indices array or an empty array if the mesh has no geometry\n   */\n  getIndices(copyWhenShared, forceCopy) {\n    if (!this._geometry) {\n      return [];\n    }\n    return this._geometry.getIndices(copyWhenShared, forceCopy);\n  }\n  get isBlocked() {\n    return this._masterMesh !== null && this._masterMesh !== undefined;\n  }\n  /**\n   * Determine if the current mesh is ready to be rendered\n   * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\n   * @param forceInstanceSupport will check if the mesh will be ready when used with instances (false by default)\n   * @returns true if all associated assets are ready (material, textures, shaders)\n   */\n  isReady() {\n    let completeCheck = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let forceInstanceSupport = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var _a, _b, _c, _d, _e, _f;\n    if (this.delayLoadState === 2) {\n      return false;\n    }\n    if (!super.isReady(completeCheck)) {\n      return false;\n    }\n    if (!this.subMeshes || this.subMeshes.length === 0) {\n      return true;\n    }\n    if (!completeCheck) {\n      return true;\n    }\n    const engine = this.getEngine();\n    const scene = this.getScene();\n    const hardwareInstancedRendering = forceInstanceSupport || engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);\n    this.computeWorldMatrix();\n    const mat = this.material || scene.defaultMaterial;\n    if (mat) {\n      if (mat._storeEffectOnSubMeshes) {\n        for (const subMesh of this.subMeshes) {\n          const effectiveMaterial = subMesh.getMaterial();\n          if (effectiveMaterial) {\n            if (effectiveMaterial._storeEffectOnSubMeshes) {\n              if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\n                return false;\n              }\n            } else {\n              if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {\n                return false;\n              }\n            }\n          }\n        }\n      } else {\n        if (!mat.isReady(this, hardwareInstancedRendering)) {\n          return false;\n        }\n      }\n    }\n    // Shadows\n    const currentRenderPassId = engine.currentRenderPassId;\n    for (const light of this.lightSources) {\n      const generators = light.getShadowGenerators();\n      if (!generators) {\n        continue;\n      }\n      const iterator = generators.values();\n      for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n        const generator = key.value;\n        if (generator && (!((_a = generator.getShadowMap()) === null || _a === void 0 ? void 0 : _a.renderList) || ((_b = generator.getShadowMap()) === null || _b === void 0 ? void 0 : _b.renderList) && ((_d = (_c = generator.getShadowMap()) === null || _c === void 0 ? void 0 : _c.renderList) === null || _d === void 0 ? void 0 : _d.indexOf(this)) !== -1)) {\n          if (generator.getShadowMap()) {\n            engine.currentRenderPassId = generator.getShadowMap().renderPassId;\n          }\n          for (const subMesh of this.subMeshes) {\n            if (!generator.isReady(subMesh, hardwareInstancedRendering, (_f = (_e = subMesh.getMaterial()) === null || _e === void 0 ? void 0 : _e.needAlphaBlendingForMesh(this)) !== null && _f !== void 0 ? _f : false)) {\n              engine.currentRenderPassId = currentRenderPassId;\n              return false;\n            }\n          }\n          engine.currentRenderPassId = currentRenderPassId;\n        }\n      }\n    }\n    // LOD\n    for (const lod of this._internalMeshDataInfo._LODLevels) {\n      if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Gets a boolean indicating if the normals aren't to be recomputed on next mesh `positions` array update. This property is pertinent only for updatable parametric shapes.\n   */\n  get areNormalsFrozen() {\n    return this._internalMeshDataInfo._areNormalsFrozen;\n  }\n  /**\n   * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It prevents the mesh normals from being recomputed on next `positions` array update.\n   * @returns the current mesh\n   */\n  freezeNormals() {\n    this._internalMeshDataInfo._areNormalsFrozen = true;\n    return this;\n  }\n  /**\n   * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It reactivates the mesh normals computation if it was previously frozen\n   * @returns the current mesh\n   */\n  unfreezeNormals() {\n    this._internalMeshDataInfo._areNormalsFrozen = false;\n    return this;\n  }\n  /**\n   * Sets a value overriding the instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs\n   */\n  set overridenInstanceCount(count) {\n    this._instanceDataStorage.overridenInstanceCount = count;\n  }\n  // Methods\n  /** @internal */\n  _preActivate() {\n    const internalDataInfo = this._internalMeshDataInfo;\n    const sceneRenderId = this.getScene().getRenderId();\n    if (internalDataInfo._preActivateId === sceneRenderId) {\n      return this;\n    }\n    internalDataInfo._preActivateId = sceneRenderId;\n    this._instanceDataStorage.visibleInstances = null;\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _preActivateForIntermediateRendering(renderId) {\n    if (this._instanceDataStorage.visibleInstances) {\n      this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;\n    }\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _registerInstanceForRenderId(instance, renderId) {\n    if (!this._instanceDataStorage.visibleInstances) {\n      this._instanceDataStorage.visibleInstances = {\n        defaultRenderId: renderId,\n        selfDefaultRenderId: this._renderId\n      };\n    }\n    if (!this._instanceDataStorage.visibleInstances[renderId]) {\n      if (this._instanceDataStorage.previousRenderId !== undefined && this._instanceDataStorage.isFrozen) {\n        this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;\n      }\n      this._instanceDataStorage.previousRenderId = renderId;\n      this._instanceDataStorage.visibleInstances[renderId] = new Array();\n    }\n    this._instanceDataStorage.visibleInstances[renderId].push(instance);\n    return this;\n  }\n  _afterComputeWorldMatrix() {\n    super._afterComputeWorldMatrix();\n    if (!this.hasThinInstances) {\n      return;\n    }\n    if (!this.doNotSyncBoundingInfo) {\n      this.thinInstanceRefreshBoundingInfo(false);\n    }\n  }\n  /** @internal */\n  _postActivate() {\n    if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {\n      this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);\n      this.edgesRenderer.customInstances.push(this.getWorldMatrix());\n    }\n  }\n  /**\n   * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n   * This means the mesh underlying bounding box and sphere are recomputed.\n   * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\n   * @param applyMorph  defines whether to apply the morph target before computing the bounding info\n   * @returns the current mesh\n   */\n  refreshBoundingInfo() {\n    let applySkeleton = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let applyMorph = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\n      return this;\n    }\n    const bias = this.geometry ? this.geometry.boundingBias : null;\n    this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), bias);\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _createGlobalSubMesh(force) {\n    const totalVertices = this.getTotalVertices();\n    if (!totalVertices || !this.getIndices()) {\n      return null;\n    }\n    // Check if we need to recreate the submeshes\n    if (this.subMeshes && this.subMeshes.length > 0) {\n      const ib = this.getIndices();\n      if (!ib) {\n        return null;\n      }\n      const totalIndices = ib.length;\n      let needToRecreate = false;\n      if (force) {\n        needToRecreate = true;\n      } else {\n        for (const submesh of this.subMeshes) {\n          if (submesh.indexStart + submesh.indexCount > totalIndices) {\n            needToRecreate = true;\n            break;\n          }\n          if (submesh.verticesStart + submesh.verticesCount > totalVertices) {\n            needToRecreate = true;\n            break;\n          }\n        }\n      }\n      if (!needToRecreate) {\n        return this.subMeshes[0];\n      }\n    }\n    this.releaseSubMeshes();\n    return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);\n  }\n  /**\n   * This function will subdivide the mesh into multiple submeshes\n   * @param count defines the expected number of submeshes\n   */\n  subdivide(count) {\n    if (count < 1) {\n      return;\n    }\n    const totalIndices = this.getTotalIndices();\n    let subdivisionSize = totalIndices / count | 0;\n    let offset = 0;\n    // Ensure that subdivisionSize is a multiple of 3\n    while (subdivisionSize % 3 !== 0) {\n      subdivisionSize++;\n    }\n    this.releaseSubMeshes();\n    for (let index = 0; index < count; index++) {\n      if (offset >= totalIndices) {\n        break;\n      }\n      SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this);\n      offset += subdivisionSize;\n    }\n    this.synchronizeInstances();\n  }\n  /**\n   * Copy a FloatArray into a specific associated vertex buffer\n   * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param data defines the data source\n   * @param updatable defines if the updated vertex buffer must be flagged as updatable\n   * @param stride defines the data stride size (can be null)\n   * @returns the current mesh\n   */\n  setVerticesData(kind, data) {\n    let updatable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let stride = arguments.length > 3 ? arguments[3] : undefined;\n    if (!this._geometry) {\n      const vertexData = new VertexData();\n      vertexData.set(data, kind);\n      const scene = this.getScene();\n      new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\n    } else {\n      this._geometry.setVerticesData(kind, data, updatable, stride);\n    }\n    return this;\n  }\n  /**\n   * Delete a vertex buffer associated with this mesh\n   * @param kind defines which buffer to delete (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   */\n  removeVerticesData(kind) {\n    if (!this._geometry) {\n      return;\n    }\n    this._geometry.removeVerticesData(kind);\n  }\n  /**\n   * Flags an associated vertex buffer as updatable\n   * @param kind defines which buffer to use (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param updatable defines if the updated vertex buffer must be flagged as updatable\n   */\n  markVerticesDataAsUpdatable(kind) {\n    let updatable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const vb = this.getVertexBuffer(kind);\n    if (!vb || vb.isUpdatable() === updatable) {\n      return;\n    }\n    this.setVerticesData(kind, this.getVerticesData(kind), updatable);\n  }\n  /**\n   * Sets the mesh global Vertex Buffer\n   * @param buffer defines the buffer to use\n   * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\n   * @returns the current mesh\n   */\n  setVerticesBuffer(buffer) {\n    let disposeExistingBuffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!this._geometry) {\n      this._geometry = Geometry.CreateGeometryForMesh(this);\n    }\n    this._geometry.setVerticesBuffer(buffer, null, disposeExistingBuffer);\n    return this;\n  }\n  /**\n   * Update a specific associated vertex buffer\n   * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   * @param data defines the data source\n   * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\n   * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\n   * @returns the current mesh\n   */\n  updateVerticesData(kind, data, updateExtends, makeItUnique) {\n    if (!this._geometry) {\n      return this;\n    }\n    if (!makeItUnique) {\n      this._geometry.updateVerticesData(kind, data, updateExtends);\n    } else {\n      this.makeGeometryUnique();\n      this.updateVerticesData(kind, data, updateExtends, false);\n    }\n    return this;\n  }\n  /**\n   * This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#other-shapes-updatemeshpositions\n   * @param positionFunction is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything\n   * @param computeNormals is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update\n   * @returns the current mesh\n   */\n  updateMeshPositions(positionFunction) {\n    let computeNormals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const positions = this.getVerticesData(VertexBuffer.PositionKind);\n    if (!positions) {\n      return this;\n    }\n    positionFunction(positions);\n    this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n    if (computeNormals) {\n      const indices = this.getIndices();\n      const normals = this.getVerticesData(VertexBuffer.NormalKind);\n      if (!normals) {\n        return this;\n      }\n      VertexData.ComputeNormals(positions, indices, normals);\n      this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\n    }\n    return this;\n  }\n  /**\n   * Creates a un-shared specific occurence of the geometry for the mesh.\n   * @returns the current mesh\n   */\n  makeGeometryUnique() {\n    if (!this._geometry) {\n      return this;\n    }\n    if (this._geometry.meshes.length === 1) {\n      return this;\n    }\n    const oldGeometry = this._geometry;\n    const geometry = this._geometry.copy(Geometry.RandomId());\n    oldGeometry.releaseForMesh(this, true);\n    geometry.applyToMesh(this);\n    return this;\n  }\n  /**\n   * Set the index buffer of this mesh\n   * @param indices defines the source data\n   * @param totalVertices defines the total number of vertices referenced by this index data (can be null)\n   * @param updatable defines if the updated index buffer must be flagged as updatable (default is false)\n   * @returns the current mesh\n   */\n  setIndices(indices) {\n    let totalVertices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let updatable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!this._geometry) {\n      const vertexData = new VertexData();\n      vertexData.indices = indices;\n      const scene = this.getScene();\n      new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\n    } else {\n      this._geometry.setIndices(indices, totalVertices, updatable);\n    }\n    return this;\n  }\n  /**\n   * Update the current index buffer\n   * @param indices defines the source data\n   * @param offset defines the offset in the index buffer where to store the new data (can be null)\n   * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n   * @returns the current mesh\n   */\n  updateIndices(indices, offset) {\n    let gpuMemoryOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!this._geometry) {\n      return this;\n    }\n    this._geometry.updateIndices(indices, offset, gpuMemoryOnly);\n    return this;\n  }\n  /**\n   * Invert the geometry to move from a right handed system to a left handed one.\n   * @returns the current mesh\n   */\n  toLeftHanded() {\n    if (!this._geometry) {\n      return this;\n    }\n    this._geometry.toLeftHanded();\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _bind(subMesh, effect, fillMode) {\n    let allowInstancedRendering = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (!this._geometry) {\n      return this;\n    }\n    const engine = this.getScene().getEngine();\n    // Morph targets\n    if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets) {\n      this.morphTargetManager._bind(effect);\n    }\n    // Wireframe\n    let indexToBind;\n    if (this._unIndexed) {\n      indexToBind = null;\n    } else {\n      switch (fillMode) {\n        case Material.PointFillMode:\n          indexToBind = null;\n          break;\n        case Material.WireFrameFillMode:\n          indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);\n          break;\n        default:\n        case Material.TriangleFillMode:\n          indexToBind = this._geometry.getIndexBuffer();\n          break;\n      }\n    }\n    // VBOs\n    if (!allowInstancedRendering || !this._userInstancedBuffersStorage || this.hasThinInstances) {\n      this._geometry._bind(effect, indexToBind);\n    } else {\n      this._geometry._bind(effect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\n    }\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _draw(subMesh, fillMode, instancesCount) {\n    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {\n      return this;\n    }\n    if (this._internalMeshDataInfo._onBeforeDrawObservable) {\n      this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);\n    }\n    const scene = this.getScene();\n    const engine = scene.getEngine();\n    if (this._unIndexed || fillMode == Material.PointFillMode) {\n      // or triangles as points\n      engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, this.forcedInstanceCount || instancesCount);\n    } else if (fillMode == Material.WireFrameFillMode) {\n      // Triangles as wireframe\n      engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, this.forcedInstanceCount || instancesCount);\n    } else {\n      engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);\n    }\n    return this;\n  }\n  /**\n   * Registers for this mesh a javascript function called just before the rendering process\n   * @param func defines the function to call before rendering this mesh\n   * @returns the current mesh\n   */\n  registerBeforeRender(func) {\n    this.onBeforeRenderObservable.add(func);\n    return this;\n  }\n  /**\n   * Disposes a previously registered javascript function called before the rendering\n   * @param func defines the function to remove\n   * @returns the current mesh\n   */\n  unregisterBeforeRender(func) {\n    this.onBeforeRenderObservable.removeCallback(func);\n    return this;\n  }\n  /**\n   * Registers for this mesh a javascript function called just after the rendering is complete\n   * @param func defines the function to call after rendering this mesh\n   * @returns the current mesh\n   */\n  registerAfterRender(func) {\n    this.onAfterRenderObservable.add(func);\n    return this;\n  }\n  /**\n   * Disposes a previously registered javascript function called after the rendering.\n   * @param func defines the function to remove\n   * @returns the current mesh\n   */\n  unregisterAfterRender(func) {\n    this.onAfterRenderObservable.removeCallback(func);\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _getInstancesRenderList(subMeshId) {\n    let isReplacementMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this._instanceDataStorage.isFrozen) {\n      if (isReplacementMode) {\n        this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[subMeshId] = false;\n        this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[subMeshId] = true;\n        return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;\n      }\n      if (this._instanceDataStorage.previousBatch) {\n        return this._instanceDataStorage.previousBatch;\n      }\n    }\n    const scene = this.getScene();\n    const isInIntermediateRendering = scene._isInIntermediateRendering();\n    const onlyForInstances = isInIntermediateRendering ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances;\n    const batchCache = this._instanceDataStorage.batchCache;\n    batchCache.mustReturn = false;\n    batchCache.renderSelf[subMeshId] = isReplacementMode || !onlyForInstances && this.isEnabled() && this.isVisible;\n    batchCache.visibleInstances[subMeshId] = null;\n    if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {\n      const visibleInstances = this._instanceDataStorage.visibleInstances;\n      const currentRenderId = scene.getRenderId();\n      const defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;\n      batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];\n      if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {\n        batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];\n      }\n    }\n    batchCache.hardwareInstancedRendering[subMeshId] = !isReplacementMode && this._instanceDataStorage.hardwareInstancedRendering && batchCache.visibleInstances[subMeshId] !== null && batchCache.visibleInstances[subMeshId] !== undefined;\n    this._instanceDataStorage.previousBatch = batchCache;\n    return batchCache;\n  }\n  /**\n   * @internal\n   */\n  _renderWithInstances(subMesh, fillMode, batch, effect, engine) {\n    var _a;\n    const visibleInstances = batch.visibleInstances[subMesh._id];\n    const visibleInstanceCount = visibleInstances ? visibleInstances.length : 0;\n    const instanceStorage = this._instanceDataStorage;\n    const currentInstancesBufferSize = instanceStorage.instancesBufferSize;\n    let instancesBuffer = instanceStorage.instancesBuffer;\n    let instancesPreviousBuffer = instanceStorage.instancesPreviousBuffer;\n    const matricesCount = visibleInstanceCount + 1;\n    const bufferSize = matricesCount * 16 * 4;\n    while (instanceStorage.instancesBufferSize < bufferSize) {\n      instanceStorage.instancesBufferSize *= 2;\n    }\n    if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\n      instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);\n    }\n    if (this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\n      instanceStorage.instancesPreviousData = new Float32Array(instanceStorage.instancesBufferSize / 4);\n    }\n    let offset = 0;\n    let instancesCount = 0;\n    const renderSelf = batch.renderSelf[subMesh._id];\n    const needUpdateBuffer = !instancesBuffer || currentInstancesBufferSize !== instanceStorage.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousBuffer;\n    if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {\n      const world = this.getWorldMatrix();\n      if (renderSelf) {\n        if (this._scene.needsPreviousWorldMatrices) {\n          if (!instanceStorage.masterMeshPreviousWorldMatrix) {\n            instanceStorage.masterMeshPreviousWorldMatrix = world.clone();\n            instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n          } else {\n            instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n            instanceStorage.masterMeshPreviousWorldMatrix.copyFrom(world);\n          }\n        }\n        world.copyToArray(instanceStorage.instancesData, offset);\n        offset += 16;\n        instancesCount++;\n      }\n      if (visibleInstances) {\n        if (Mesh.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMesh.getRenderingMesh()))) {\n          const cameraPosition = this._scene.activeCamera.globalPosition;\n          for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\n            const instanceMesh = visibleInstances[instanceIndex];\n            instanceMesh._distanceToCamera = Vector3.Distance(instanceMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\n          }\n          visibleInstances.sort((m1, m2) => {\n            return m1._distanceToCamera > m2._distanceToCamera ? -1 : m1._distanceToCamera < m2._distanceToCamera ? 1 : 0;\n          });\n        }\n        for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\n          const instance = visibleInstances[instanceIndex];\n          const matrix = instance.getWorldMatrix();\n          matrix.copyToArray(instanceStorage.instancesData, offset);\n          if (this._scene.needsPreviousWorldMatrices) {\n            if (!instance._previousWorldMatrix) {\n              instance._previousWorldMatrix = matrix.clone();\n              instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n            } else {\n              instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n              instance._previousWorldMatrix.copyFrom(matrix);\n            }\n          }\n          offset += 16;\n          instancesCount++;\n        }\n      }\n    } else {\n      instancesCount = (renderSelf ? 1 : 0) + visibleInstanceCount;\n    }\n    if (needUpdateBuffer) {\n      if (instancesBuffer) {\n        instancesBuffer.dispose();\n      }\n      if (instancesPreviousBuffer) {\n        instancesPreviousBuffer.dispose();\n      }\n      instancesBuffer = new Buffer(engine, instanceStorage.instancesData, true, 16, false, true);\n      instanceStorage.instancesBuffer = instancesBuffer;\n      if (!this._userInstancedBuffersStorage) {\n        this._userInstancedBuffersStorage = {\n          data: {},\n          vertexBuffers: {},\n          strides: {},\n          sizes: {},\n          vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined\n        };\n      }\n      this._userInstancedBuffersStorage.vertexBuffers[\"world0\"] = instancesBuffer.createVertexBuffer(\"world0\", 0, 4);\n      this._userInstancedBuffersStorage.vertexBuffers[\"world1\"] = instancesBuffer.createVertexBuffer(\"world1\", 4, 4);\n      this._userInstancedBuffersStorage.vertexBuffers[\"world2\"] = instancesBuffer.createVertexBuffer(\"world2\", 8, 4);\n      this._userInstancedBuffersStorage.vertexBuffers[\"world3\"] = instancesBuffer.createVertexBuffer(\"world3\", 12, 4);\n      if (this._scene.needsPreviousWorldMatrices) {\n        instancesPreviousBuffer = new Buffer(engine, instanceStorage.instancesPreviousData, true, 16, false, true);\n        instanceStorage.instancesPreviousBuffer = instancesPreviousBuffer;\n        this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld0\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld0\", 0, 4);\n        this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld1\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld1\", 4, 4);\n        this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld2\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld2\", 8, 4);\n        this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld3\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld3\", 12, 4);\n      }\n      this._invalidateInstanceVertexArrayObject();\n    } else {\n      if (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) {\n        instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\n        if (this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate)) {\n          instancesPreviousBuffer.updateDirectly(instanceStorage.instancesPreviousData, 0, instancesCount);\n        }\n      }\n    }\n    this._processInstancedBuffers(visibleInstances, renderSelf);\n    // Stats\n    this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\n    // Draw\n    if (engine._currentDrawContext) {\n      engine._currentDrawContext.useInstancing = true;\n    }\n    this._bind(subMesh, effect, fillMode);\n    this._draw(subMesh, fillMode, instancesCount);\n    // Write current matrices as previous matrices in case of manual update\n    // Default behaviour when previous matrices are not specified explicitly\n    // Will break if instances number/order changes\n    if (this._scene.needsPreviousWorldMatrices && !needUpdateBuffer && this._instanceDataStorage.manualUpdate && (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) && !this._instanceDataStorage.previousManualUpdate) {\n      instancesPreviousBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\n    }\n    engine.unbindInstanceAttributes();\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _renderWithThinInstances(subMesh, fillMode, effect, engine) {\n    var _a, _b;\n    // Stats\n    const instancesCount = (_b = (_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.instancesCount) !== null && _b !== void 0 ? _b : 0;\n    this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);\n    // Draw\n    if (engine._currentDrawContext) {\n      engine._currentDrawContext.useInstancing = true;\n    }\n    this._bind(subMesh, effect, fillMode);\n    this._draw(subMesh, fillMode, instancesCount);\n    // Write current matrices as previous matrices\n    // Default behaviour when previous matrices are not specified explicitly\n    // Will break if instances number/order changes\n    if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData) {\n      if (!this._thinInstanceDataStorage.previousMatrixBuffer) {\n        this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", this._thinInstanceDataStorage.matrixData, false);\n      } else {\n        this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, instancesCount);\n      }\n    }\n    engine.unbindInstanceAttributes();\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _processInstancedBuffers(visibleInstances, renderSelf) {\n    // Do nothing\n  }\n  /**\n   * @internal\n   */\n  _processRendering(renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {\n    const scene = this.getScene();\n    const engine = scene.getEngine();\n    if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {\n      this._renderWithThinInstances(subMesh, fillMode, effect, engine);\n      return this;\n    }\n    if (hardwareInstancedRendering) {\n      this._renderWithInstances(subMesh, fillMode, batch, effect, engine);\n    } else {\n      if (engine._currentDrawContext) {\n        engine._currentDrawContext.useInstancing = false;\n      }\n      let instanceCount = 0;\n      if (batch.renderSelf[subMesh._id]) {\n        // Draw\n        if (onBeforeDraw) {\n          onBeforeDraw(false, renderingMesh.getWorldMatrix(), effectiveMaterial);\n        }\n        instanceCount++;\n        this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);\n      }\n      const visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];\n      if (visibleInstancesForSubMesh) {\n        const visibleInstanceCount = visibleInstancesForSubMesh.length;\n        instanceCount += visibleInstanceCount;\n        // Stats\n        for (let instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {\n          const instance = visibleInstancesForSubMesh[instanceIndex];\n          // World\n          const world = instance.getWorldMatrix();\n          if (onBeforeDraw) {\n            onBeforeDraw(true, world, effectiveMaterial);\n          }\n          // Draw\n          this._draw(subMesh, fillMode);\n        }\n      }\n      // Stats\n      scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);\n    }\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _rebuild() {\n    let dispose = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this._instanceDataStorage.instancesBuffer) {\n      // Dispose instance buffer to be recreated in _renderWithInstances when rendered\n      if (dispose) {\n        this._instanceDataStorage.instancesBuffer.dispose();\n      }\n      this._instanceDataStorage.instancesBuffer = null;\n    }\n    if (this._userInstancedBuffersStorage) {\n      for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {\n        const buffer = this._userInstancedBuffersStorage.vertexBuffers[kind];\n        if (buffer) {\n          // Dispose instance buffer to be recreated in _renderWithInstances when rendered\n          if (dispose) {\n            buffer.dispose();\n          }\n          this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\n        }\n      }\n      if (this._userInstancedBuffersStorage.vertexArrayObjects) {\n        this._userInstancedBuffersStorage.vertexArrayObjects = {};\n      }\n    }\n    this._internalMeshDataInfo._effectiveMaterial = null;\n    super._rebuild(dispose);\n  }\n  /** @internal */\n  _freeze() {\n    if (!this.subMeshes) {\n      return;\n    }\n    // Prepare batches\n    for (let index = 0; index < this.subMeshes.length; index++) {\n      this._getInstancesRenderList(index);\n    }\n    this._internalMeshDataInfo._effectiveMaterial = null;\n    this._instanceDataStorage.isFrozen = true;\n  }\n  /** @internal */\n  _unFreeze() {\n    this._instanceDataStorage.isFrozen = false;\n    this._instanceDataStorage.previousBatch = null;\n  }\n  /**\n   * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\n   * @param subMesh defines the subMesh to render\n   * @param enableAlphaMode defines if alpha mode can be changed\n   * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\n   * @returns the current mesh\n   */\n  render(subMesh, enableAlphaMode, effectiveMeshReplacement) {\n    var _a, _b, _c;\n    const scene = this.getScene();\n    if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {\n      this._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n    } else {\n      this._internalAbstractMeshDataInfo._isActive = false;\n    }\n    if (this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) {\n      return this;\n    }\n    // Managing instances\n    const batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);\n    if (batch.mustReturn) {\n      return this;\n    }\n    // Checking geometry state\n    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {\n      return this;\n    }\n    const engine = scene.getEngine();\n    let oldCameraMaxZ = 0;\n    let oldCamera = null;\n    if (this.ignoreCameraMaxZ && scene.activeCamera && !scene._isInIntermediateRendering()) {\n      oldCameraMaxZ = scene.activeCamera.maxZ;\n      oldCamera = scene.activeCamera;\n      scene.activeCamera.maxZ = 0;\n      scene.updateTransformMatrix(true);\n    }\n    if (this._internalMeshDataInfo._onBeforeRenderObservable) {\n      this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);\n    }\n    const renderingMesh = subMesh.getRenderingMesh();\n    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances || !!this._userInstancedBuffersStorage && !subMesh.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh;\n    const instanceDataStorage = this._instanceDataStorage;\n    const material = subMesh.getMaterial();\n    if (!material) {\n      if (oldCamera) {\n        oldCamera.maxZ = oldCameraMaxZ;\n        scene.updateTransformMatrix(true);\n      }\n      return this;\n    }\n    // Material\n    if (!instanceDataStorage.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== material) {\n      if (material._storeEffectOnSubMeshes) {\n        if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\n          if (oldCamera) {\n            oldCamera.maxZ = oldCameraMaxZ;\n            scene.updateTransformMatrix(true);\n          }\n          return this;\n        }\n      } else if (!material.isReady(this, hardwareInstancedRendering)) {\n        if (oldCamera) {\n          oldCamera.maxZ = oldCameraMaxZ;\n          scene.updateTransformMatrix(true);\n        }\n        return this;\n      }\n      this._internalMeshDataInfo._effectiveMaterial = material;\n    } else if (material._storeEffectOnSubMeshes && !((_a = subMesh.effect) === null || _a === void 0 ? void 0 : _a._wasPreviouslyReady) || !material._storeEffectOnSubMeshes && !((_b = material.getEffect()) === null || _b === void 0 ? void 0 : _b._wasPreviouslyReady)) {\n      if (oldCamera) {\n        oldCamera.maxZ = oldCameraMaxZ;\n        scene.updateTransformMatrix(true);\n      }\n      return this;\n    }\n    // Alpha mode\n    if (enableAlphaMode) {\n      engine.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);\n    }\n    let drawWrapper;\n    if (this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes) {\n      drawWrapper = subMesh._drawWrapper;\n    } else {\n      drawWrapper = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();\n    }\n    const effect = (_c = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _c !== void 0 ? _c : null;\n    for (const step of scene._beforeRenderingMeshStage) {\n      step.action(this, subMesh, batch, effect);\n    }\n    if (!drawWrapper || !effect) {\n      if (oldCamera) {\n        oldCamera.maxZ = oldCameraMaxZ;\n        scene.updateTransformMatrix(true);\n      }\n      return this;\n    }\n    const effectiveMesh = effectiveMeshReplacement || this;\n    let sideOrientation;\n    if (!instanceDataStorage.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {\n      const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n      sideOrientation = this.overrideMaterialSideOrientation;\n      if (sideOrientation == null) {\n        sideOrientation = this._internalMeshDataInfo._effectiveMaterial.sideOrientation;\n      }\n      if (mainDeterminant < 0) {\n        sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n      }\n      instanceDataStorage.sideOrientation = sideOrientation;\n    } else {\n      sideOrientation = instanceDataStorage.sideOrientation;\n    }\n    const reverse = this._internalMeshDataInfo._effectiveMaterial._preBind(drawWrapper, sideOrientation);\n    if (this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite) {\n      engine.setDepthWrite(true);\n    }\n    // Bind\n    const fillMode = scene.forcePointsCloud ? Material.PointFillMode : scene.forceWireframe ? Material.WireFrameFillMode : this._internalMeshDataInfo._effectiveMaterial.fillMode;\n    if (this._internalMeshDataInfo._onBeforeBindObservable) {\n      this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);\n    }\n    if (!hardwareInstancedRendering) {\n      // Binding will be done later because we need to add more info to the VB\n      this._bind(subMesh, effect, fillMode, false);\n    }\n    const effectiveMaterial = this._internalMeshDataInfo._effectiveMaterial;\n    const world = effectiveMesh.getWorldMatrix();\n    if (effectiveMaterial._storeEffectOnSubMeshes) {\n      effectiveMaterial.bindForSubMesh(world, this, subMesh);\n    } else {\n      effectiveMaterial.bind(world, this);\n    }\n    if (!effectiveMaterial.backFaceCulling && effectiveMaterial.separateCullingPass) {\n      engine.setState(true, effectiveMaterial.zOffset, false, !reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\n      this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);\n      engine.setState(true, effectiveMaterial.zOffset, false, reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\n      if (this._internalMeshDataInfo._onBetweenPassObservable) {\n        this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(subMesh);\n      }\n    }\n    // Draw\n    this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);\n    // Unbind\n    this._internalMeshDataInfo._effectiveMaterial.unbind();\n    for (const step of scene._afterRenderingMeshStage) {\n      step.action(this, subMesh, batch, effect);\n    }\n    if (this._internalMeshDataInfo._onAfterRenderObservable) {\n      this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);\n    }\n    if (oldCamera) {\n      oldCamera.maxZ = oldCameraMaxZ;\n      scene.updateTransformMatrix(true);\n    }\n    if (scene.performancePriority === ScenePerformancePriority.Aggressive && !instanceDataStorage.isFrozen) {\n      this._freeze();\n    }\n    return this;\n  }\n  /**\n   *   Renormalize the mesh and patch it up if there are no weights\n   *   Similar to normalization by adding the weights compute the reciprocal and multiply all elements, this wil ensure that everything adds to 1.\n   *   However in the case of zero weights then we set just a single influence to 1.\n   *   We check in the function for extra's present and if so we use the normalizeSkinWeightsWithExtras rather than the FourWeights version.\n   */\n  cleanMatrixWeights() {\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\n        this._normalizeSkinWeightsAndExtra();\n      } else {\n        this._normalizeSkinFourWeights();\n      }\n    }\n  }\n  // faster 4 weight version.\n  _normalizeSkinFourWeights() {\n    const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    const numWeights = matricesWeights.length;\n    for (let a = 0; a < numWeights; a += 4) {\n      // accumulate weights\n      const t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\n      // check for invalid weight and just set it to 1.\n      if (t === 0) {\n        matricesWeights[a] = 1;\n      } else {\n        // renormalize so everything adds to 1 use reciprocal\n        const recip = 1 / t;\n        matricesWeights[a] *= recip;\n        matricesWeights[a + 1] *= recip;\n        matricesWeights[a + 2] *= recip;\n        matricesWeights[a + 3] *= recip;\n      }\n    }\n    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\n  }\n  // handle special case of extra verts.  (in theory gltf can handle 12 influences)\n  _normalizeSkinWeightsAndExtra() {\n    const matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\n    const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    const numWeights = matricesWeights.length;\n    for (let a = 0; a < numWeights; a += 4) {\n      // accumulate weights\n      let t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\n      t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];\n      // check for invalid weight and just set it to 1.\n      if (t === 0) {\n        matricesWeights[a] = 1;\n      } else {\n        // renormalize so everything adds to 1 use reciprocal\n        const recip = 1 / t;\n        matricesWeights[a] *= recip;\n        matricesWeights[a + 1] *= recip;\n        matricesWeights[a + 2] *= recip;\n        matricesWeights[a + 3] *= recip;\n        // same goes for extras\n        matricesWeightsExtra[a] *= recip;\n        matricesWeightsExtra[a + 1] *= recip;\n        matricesWeightsExtra[a + 2] *= recip;\n        matricesWeightsExtra[a + 3] *= recip;\n      }\n    }\n    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\n    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);\n  }\n  /**\n   * ValidateSkinning is used to determine that a mesh has valid skinning data along with skin metrics, if missing weights,\n   * or not normalized it is returned as invalid mesh the string can be used for console logs, or on screen messages to let\n   * the user know there was an issue with importing the mesh\n   * @returns a validation object with skinned, valid and report string\n   */\n  validateSkinning() {\n    const matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\n    const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    if (matricesWeights === null || this.skeleton == null) {\n      return {\n        skinned: false,\n        valid: true,\n        report: \"not skinned\"\n      };\n    }\n    const numWeights = matricesWeights.length;\n    let numberNotSorted = 0;\n    let missingWeights = 0;\n    let maxUsedWeights = 0;\n    let numberNotNormalized = 0;\n    const numInfluences = matricesWeightsExtra === null ? 4 : 8;\n    const usedWeightCounts = new Array();\n    for (let a = 0; a <= numInfluences; a++) {\n      usedWeightCounts[a] = 0;\n    }\n    const toleranceEpsilon = 0.001;\n    for (let a = 0; a < numWeights; a += 4) {\n      let lastWeight = matricesWeights[a];\n      let t = lastWeight;\n      let usedWeights = t === 0 ? 0 : 1;\n      for (let b = 1; b < numInfluences; b++) {\n        const d = b < 4 ? matricesWeights[a + b] : matricesWeightsExtra[a + b - 4];\n        if (d > lastWeight) {\n          numberNotSorted++;\n        }\n        if (d !== 0) {\n          usedWeights++;\n        }\n        t += d;\n        lastWeight = d;\n      }\n      // count the buffer weights usage\n      usedWeightCounts[usedWeights]++;\n      // max influences\n      if (usedWeights > maxUsedWeights) {\n        maxUsedWeights = usedWeights;\n      }\n      // check for invalid weight and just set it to 1.\n      if (t === 0) {\n        missingWeights++;\n      } else {\n        // renormalize so everything adds to 1 use reciprocal\n        const recip = 1 / t;\n        let tolerance = 0;\n        for (let b = 0; b < numInfluences; b++) {\n          if (b < 4) {\n            tolerance += Math.abs(matricesWeights[a + b] - matricesWeights[a + b] * recip);\n          } else {\n            tolerance += Math.abs(matricesWeightsExtra[a + b - 4] - matricesWeightsExtra[a + b - 4] * recip);\n          }\n        }\n        // arbitrary epsilon value for dictating not normalized\n        if (tolerance > toleranceEpsilon) {\n          numberNotNormalized++;\n        }\n      }\n    }\n    // validate bone indices are in range of the skeleton\n    const numBones = this.skeleton.bones.length;\n    const matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    const matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\n    let numBadBoneIndices = 0;\n    for (let a = 0; a < numWeights; a += 4) {\n      for (let b = 0; b < numInfluences; b++) {\n        const index = b < 4 ? matricesIndices[a + b] : matricesIndicesExtra[a + b - 4];\n        if (index >= numBones || index < 0) {\n          numBadBoneIndices++;\n        }\n      }\n    }\n    // log mesh stats\n    const output = \"Number of Weights = \" + numWeights / 4 + \"\\nMaximum influences = \" + maxUsedWeights + \"\\nMissing Weights = \" + missingWeights + \"\\nNot Sorted = \" + numberNotSorted + \"\\nNot Normalized = \" + numberNotNormalized + \"\\nWeightCounts = [\" + usedWeightCounts + \"]\" + \"\\nNumber of bones = \" + numBones + \"\\nBad Bone Indices = \" + numBadBoneIndices;\n    return {\n      skinned: true,\n      valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0,\n      report: output\n    };\n  }\n  /** @internal */\n  _checkDelayState() {\n    const scene = this.getScene();\n    if (this._geometry) {\n      this._geometry.load(scene);\n    } else if (this.delayLoadState === 4) {\n      this.delayLoadState = 2;\n      this._queueLoad(scene);\n    }\n    return this;\n  }\n  _queueLoad(scene) {\n    scene.addPendingData(this);\n    const getBinaryData = this.delayLoadingFile.indexOf(\".babylonbinarymeshdata\") !== -1;\n    Tools.LoadFile(this.delayLoadingFile, data => {\n      if (data instanceof ArrayBuffer) {\n        this._delayLoadingFunction(data, this);\n      } else {\n        this._delayLoadingFunction(JSON.parse(data), this);\n      }\n      this.instances.forEach(instance => {\n        instance.refreshBoundingInfo();\n        instance._syncSubMeshes();\n      });\n      this.delayLoadState = 1;\n      scene.removePendingData(this);\n    }, () => {}, scene.offlineProvider, getBinaryData);\n    return this;\n  }\n  /**\n   * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\n   * A mesh is in the frustum if its bounding box intersects the frustum\n   * @param frustumPlanes defines the frustum to test\n   * @returns true if the mesh is in the frustum planes\n   */\n  isInFrustum(frustumPlanes) {\n    if (this.delayLoadState === 2) {\n      return false;\n    }\n    if (!super.isInFrustum(frustumPlanes)) {\n      return false;\n    }\n    this._checkDelayState();\n    return true;\n  }\n  /**\n   * Sets the mesh material by the material or multiMaterial `id` property\n   * @param id is a string identifying the material or the multiMaterial\n   * @returns the current mesh\n   */\n  setMaterialById(id) {\n    const materials = this.getScene().materials;\n    let index;\n    for (index = materials.length - 1; index > -1; index--) {\n      if (materials[index].id === id) {\n        this.material = materials[index];\n        return this;\n      }\n    }\n    // Multi\n    const multiMaterials = this.getScene().multiMaterials;\n    for (index = multiMaterials.length - 1; index > -1; index--) {\n      if (multiMaterials[index].id === id) {\n        this.material = multiMaterials[index];\n        return this;\n      }\n    }\n    return this;\n  }\n  /**\n   * Returns as a new array populated with the mesh material and/or skeleton, if any.\n   * @returns an array of IAnimatable\n   */\n  getAnimatables() {\n    const results = new Array();\n    if (this.material) {\n      results.push(this.material);\n    }\n    if (this.skeleton) {\n      results.push(this.skeleton);\n    }\n    return results;\n  }\n  /**\n   * Modifies the mesh geometry according to the passed transformation matrix.\n   * This method returns nothing, but it really modifies the mesh even if it's originally not set as updatable.\n   * The mesh normals are modified using the same transformation.\n   * Note that, under the hood, this method sets a new VertexBuffer each call.\n   * @param transform defines the transform matrix to use\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms\n   * @returns the current mesh\n   */\n  bakeTransformIntoVertices(transform) {\n    // Position\n    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      return this;\n    }\n    const submeshes = this.subMeshes.splice(0);\n    this._resetPointsArrayCache();\n    let data = this.getVerticesData(VertexBuffer.PositionKind);\n    const temp = Vector3.Zero();\n    let index;\n    for (index = 0; index < data.length; index += 3) {\n      Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).toArray(data, index);\n    }\n    this.setVerticesData(VertexBuffer.PositionKind, data, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable());\n    // Normals\n    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      data = this.getVerticesData(VertexBuffer.NormalKind);\n      for (index = 0; index < data.length; index += 3) {\n        Vector3.TransformNormalFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).normalize().toArray(data, index);\n      }\n      this.setVerticesData(VertexBuffer.NormalKind, data, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());\n    }\n    // flip faces?\n    if (transform.determinant() < 0) {\n      this.flipFaces();\n    }\n    // Restore submeshes\n    this.releaseSubMeshes();\n    this.subMeshes = submeshes;\n    return this;\n  }\n  /**\n   * Modifies the mesh geometry according to its own current World Matrix.\n   * The mesh World Matrix is then reset.\n   * This method returns nothing but really modifies the mesh even if it's originally not set as updatable.\n   * Note that, under the hood, this method sets a new VertexBuffer each call.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms\n   * @param bakeIndependentlyOfChildren indicates whether to preserve all child nodes' World Matrix during baking\n   * @returns the current mesh\n   */\n  bakeCurrentTransformIntoVertices() {\n    let bakeIndependentlyOfChildren = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.bakeTransformIntoVertices(this.computeWorldMatrix(true));\n    this.resetLocalMatrix(bakeIndependentlyOfChildren);\n    return this;\n  }\n  // Cache\n  /** @internal */\n  get _positions() {\n    if (this._internalAbstractMeshDataInfo._positions) {\n      return this._internalAbstractMeshDataInfo._positions;\n    }\n    if (this._geometry) {\n      return this._geometry._positions;\n    }\n    return null;\n  }\n  /** @internal */\n  _resetPointsArrayCache() {\n    if (this._geometry) {\n      this._geometry._resetPointsArrayCache();\n    }\n    return this;\n  }\n  /** @internal */\n  _generatePointsArray() {\n    if (this._geometry) {\n      return this._geometry._generatePointsArray();\n    }\n    return false;\n  }\n  /**\n   * Returns a new Mesh object generated from the current mesh properties.\n   * This method must not get confused with createInstance()\n   * @param name is a string, the name given to the new mesh\n   * @param newParent can be any Node object (default `null`)\n   * @param doNotCloneChildren allows/denies the recursive cloning of the original mesh children if any (default `false`)\n   * @param clonePhysicsImpostor allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any (default `true`)\n   * @returns a new mesh\n   */\n  clone() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let newParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let doNotCloneChildren = arguments.length > 2 ? arguments[2] : undefined;\n    let clonePhysicsImpostor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    return new Mesh(name, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);\n  }\n  /**\n   * Releases resources associated with this mesh.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n  dispose(doNotRecurse) {\n    let disposeMaterialAndTextures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.morphTargetManager = null;\n    if (this._geometry) {\n      this._geometry.releaseForMesh(this, true);\n    }\n    const internalDataInfo = this._internalMeshDataInfo;\n    if (internalDataInfo._onBeforeDrawObservable) {\n      internalDataInfo._onBeforeDrawObservable.clear();\n    }\n    if (internalDataInfo._onBeforeBindObservable) {\n      internalDataInfo._onBeforeBindObservable.clear();\n    }\n    if (internalDataInfo._onBeforeRenderObservable) {\n      internalDataInfo._onBeforeRenderObservable.clear();\n    }\n    if (internalDataInfo._onAfterRenderObservable) {\n      internalDataInfo._onAfterRenderObservable.clear();\n    }\n    if (internalDataInfo._onBetweenPassObservable) {\n      internalDataInfo._onBetweenPassObservable.clear();\n    }\n    // Sources\n    if (this._scene.useClonedMeshMap) {\n      if (internalDataInfo.meshMap) {\n        for (const uniqueId in internalDataInfo.meshMap) {\n          const mesh = internalDataInfo.meshMap[uniqueId];\n          if (mesh) {\n            mesh._internalMeshDataInfo._source = null;\n            internalDataInfo.meshMap[uniqueId] = undefined;\n          }\n        }\n      }\n      if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {\n        internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = undefined;\n      }\n    } else {\n      const meshes = this.getScene().meshes;\n      for (const abstractMesh of meshes) {\n        const mesh = abstractMesh;\n        if (mesh._internalMeshDataInfo && mesh._internalMeshDataInfo._source && mesh._internalMeshDataInfo._source === this) {\n          mesh._internalMeshDataInfo._source = null;\n        }\n      }\n    }\n    internalDataInfo._source = null;\n    this._instanceDataStorage.visibleInstances = {};\n    // Instances\n    this._disposeInstanceSpecificData();\n    // Thin instances\n    this._disposeThinInstanceSpecificData();\n    if (this._internalMeshDataInfo._checkReadinessObserver) {\n      this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);\n    }\n    super.dispose(doNotRecurse, disposeMaterialAndTextures);\n  }\n  /** @internal */\n  _disposeInstanceSpecificData() {\n    // Do nothing\n  }\n  /** @internal */\n  _disposeThinInstanceSpecificData() {\n    // Do nothing\n  }\n  /** @internal */\n  _invalidateInstanceVertexArrayObject() {\n    // Do nothing\n  }\n  /**\n   * Modifies the mesh geometry according to a displacement map.\n   * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n   * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n   * @param url is a string, the URL from the image file is to be downloaded.\n   * @param minHeight is the lower limit of the displacement.\n   * @param maxHeight is the upper limit of the displacement.\n   * @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.\n   * @param uvOffset is an optional vector2 used to offset UV.\n   * @param uvScale is an optional vector2 used to scale UV.\n   * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\n   * @returns the Mesh.\n   */\n  applyDisplacementMap(url, minHeight, maxHeight, onSuccess, uvOffset, uvScale) {\n    let forceUpdate = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    const scene = this.getScene();\n    const onload = img => {\n      // Getting height map data\n      const heightMapWidth = img.width;\n      const heightMapHeight = img.height;\n      const canvas = this.getEngine().createCanvas(heightMapWidth, heightMapHeight);\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(img, 0, 0);\n      // Create VertexData from map data\n      //Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\n      const buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;\n      this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);\n      //execute success callback, if set\n      if (onSuccess) {\n        onSuccess(this);\n      }\n    };\n    Tools.LoadImage(url, onload, () => {}, scene.offlineProvider);\n    return this;\n  }\n  /**\n   * Modifies the mesh geometry according to a displacementMap buffer.\n   * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n   * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n   * @param buffer is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.\n   * @param heightMapWidth is the width of the buffer image.\n   * @param heightMapHeight is the height of the buffer image.\n   * @param minHeight is the lower limit of the displacement.\n   * @param maxHeight is the upper limit of the displacement.\n   * @param uvOffset is an optional vector2 used to offset UV.\n   * @param uvScale is an optional vector2 used to scale UV.\n   * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\n   * @returns the Mesh.\n   */\n  applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale) {\n    let forceUpdate = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      Logger.Warn(\"Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing\");\n      return this;\n    }\n    const positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);\n    const normals = this.getVerticesData(VertexBuffer.NormalKind);\n    const uvs = this.getVerticesData(VertexBuffer.UVKind);\n    let position = Vector3.Zero();\n    const normal = Vector3.Zero();\n    const uv = Vector2.Zero();\n    uvOffset = uvOffset || Vector2.Zero();\n    uvScale = uvScale || new Vector2(1, 1);\n    for (let index = 0; index < positions.length; index += 3) {\n      Vector3.FromArrayToRef(positions, index, position);\n      Vector3.FromArrayToRef(normals, index, normal);\n      Vector2.FromArrayToRef(uvs, index / 3 * 2, uv);\n      // Compute height\n      const u = Math.abs(uv.x * uvScale.x + uvOffset.x % 1) * (heightMapWidth - 1) % heightMapWidth | 0;\n      const v = Math.abs(uv.y * uvScale.y + uvOffset.y % 1) * (heightMapHeight - 1) % heightMapHeight | 0;\n      const pos = (u + v * heightMapWidth) * 4;\n      const r = buffer[pos] / 255.0;\n      const g = buffer[pos + 1] / 255.0;\n      const b = buffer[pos + 2] / 255.0;\n      const gradient = r * 0.3 + g * 0.59 + b * 0.11;\n      normal.normalize();\n      normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);\n      position = position.add(normal);\n      position.toArray(positions, index);\n    }\n    VertexData.ComputeNormals(positions, this.getIndices(), normals);\n    if (forceUpdate) {\n      this.setVerticesData(VertexBuffer.PositionKind, positions);\n      this.setVerticesData(VertexBuffer.NormalKind, normals);\n      this.setVerticesData(VertexBuffer.UVKind, uvs);\n    } else {\n      this.updateVerticesData(VertexBuffer.PositionKind, positions);\n      this.updateVerticesData(VertexBuffer.NormalKind, normals);\n    }\n    return this;\n  }\n  /**\n   * Modify the mesh to get a flat shading rendering.\n   * This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.\n   * Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.\n   * @returns current mesh\n   */\n  convertToFlatShadedMesh() {\n    const kinds = this.getVerticesDataKinds();\n    const vbs = {};\n    const data = {};\n    const newdata = {};\n    let updatableNormals = false;\n    let kindIndex;\n    let kind;\n    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n      kind = kinds[kindIndex];\n      const vertexBuffer = this.getVertexBuffer(kind);\n      // Check data consistency\n      const vertexData = vertexBuffer.getData();\n      if (vertexData instanceof Array || vertexData instanceof Float32Array) {\n        if (vertexData.length === 0) {\n          continue;\n        }\n      }\n      if (kind === VertexBuffer.NormalKind) {\n        updatableNormals = vertexBuffer.isUpdatable();\n        kinds.splice(kindIndex, 1);\n        kindIndex--;\n        continue;\n      }\n      vbs[kind] = vertexBuffer;\n      data[kind] = this.getVerticesData(kind);\n      newdata[kind] = [];\n    }\n    // Save previous submeshes\n    const previousSubmeshes = this.subMeshes.slice(0);\n    const indices = this.getIndices();\n    const totalIndices = this.getTotalIndices();\n    // Generating unique vertices per face\n    let index;\n    for (index = 0; index < totalIndices; index++) {\n      const vertexIndex = indices[index];\n      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n        kind = kinds[kindIndex];\n        if (!vbs[kind]) {\n          continue;\n        }\n        const stride = vbs[kind].getStrideSize();\n        for (let offset = 0; offset < stride; offset++) {\n          newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n        }\n      }\n    }\n    // Updating faces & normal\n    const normals = [];\n    const positions = newdata[VertexBuffer.PositionKind];\n    const useRightHandedSystem = this.getScene().useRightHandedSystem;\n    let flipNormalGeneration;\n    if (useRightHandedSystem) {\n      flipNormalGeneration = this.overrideMaterialSideOrientation === 1;\n    } else {\n      flipNormalGeneration = this.overrideMaterialSideOrientation === 0;\n    }\n    for (index = 0; index < totalIndices; index += 3) {\n      indices[index] = index;\n      indices[index + 1] = index + 1;\n      indices[index + 2] = index + 2;\n      const p1 = Vector3.FromArray(positions, index * 3);\n      const p2 = Vector3.FromArray(positions, (index + 1) * 3);\n      const p3 = Vector3.FromArray(positions, (index + 2) * 3);\n      const p1p2 = p1.subtract(p2);\n      const p3p2 = p3.subtract(p2);\n      const normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));\n      if (flipNormalGeneration) {\n        normal.scaleInPlace(-1);\n      }\n      // Store same normals for every vertex\n      for (let localIndex = 0; localIndex < 3; localIndex++) {\n        normals.push(normal.x);\n        normals.push(normal.y);\n        normals.push(normal.z);\n      }\n    }\n    this.setIndices(indices);\n    this.setVerticesData(VertexBuffer.NormalKind, normals, updatableNormals);\n    // Updating vertex buffers\n    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n      kind = kinds[kindIndex];\n      if (!newdata[kind]) {\n        continue;\n      }\n      this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());\n    }\n    // Updating submeshes\n    this.releaseSubMeshes();\n    for (let submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n      const previousOne = previousSubmeshes[submeshIndex];\n      SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n    }\n    this.synchronizeInstances();\n    return this;\n  }\n  /**\n   * This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.\n   * In other words, more vertices, no more indices and a single bigger VBO.\n   * The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.\n   * @returns current mesh\n   */\n  convertToUnIndexedMesh() {\n    const kinds = this.getVerticesDataKinds();\n    const vbs = {};\n    const data = {};\n    const newdata = {};\n    let kindIndex;\n    let kind;\n    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n      kind = kinds[kindIndex];\n      const vertexBuffer = this.getVertexBuffer(kind);\n      vbs[kind] = vertexBuffer;\n      data[kind] = vbs[kind].getData();\n      newdata[kind] = [];\n    }\n    // Save previous submeshes\n    const previousSubmeshes = this.subMeshes.slice(0);\n    const indices = this.getIndices();\n    const totalIndices = this.getTotalIndices();\n    // Generating unique vertices per face\n    let index;\n    for (index = 0; index < totalIndices; index++) {\n      const vertexIndex = indices[index];\n      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n        kind = kinds[kindIndex];\n        const stride = vbs[kind].getStrideSize();\n        for (let offset = 0; offset < stride; offset++) {\n          newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n        }\n      }\n    }\n    // Updating indices\n    for (index = 0; index < totalIndices; index += 3) {\n      indices[index] = index;\n      indices[index + 1] = index + 1;\n      indices[index + 2] = index + 2;\n    }\n    this.setIndices(indices);\n    // Updating vertex buffers\n    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n      kind = kinds[kindIndex];\n      this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable(), vbs[kind].getStrideSize());\n    }\n    // Updating submeshes\n    this.releaseSubMeshes();\n    for (let submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n      const previousOne = previousSubmeshes[submeshIndex];\n      SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n    }\n    this._unIndexed = true;\n    this.synchronizeInstances();\n    return this;\n  }\n  /**\n   * Inverses facet orientations.\n   * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n   * @param flipNormals will also inverts the normals\n   * @returns current mesh\n   */\n  flipFaces() {\n    let flipNormals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const vertex_data = VertexData.ExtractFromMesh(this);\n    let i;\n    if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {\n      for (i = 0; i < vertex_data.normals.length; i++) {\n        vertex_data.normals[i] *= -1;\n      }\n    }\n    if (vertex_data.indices) {\n      let temp;\n      for (i = 0; i < vertex_data.indices.length; i += 3) {\n        // reassign indices\n        temp = vertex_data.indices[i + 1];\n        vertex_data.indices[i + 1] = vertex_data.indices[i + 2];\n        vertex_data.indices[i + 2] = temp;\n      }\n    }\n    vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n    return this;\n  }\n  /**\n   * Increase the number of facets and hence vertices in a mesh\n   * Vertex normals are interpolated from existing vertex normals\n   * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n   * @param numberPerEdge the number of new vertices to add to each edge of a facet, optional default 1\n   */\n  increaseVertices() {\n    let numberPerEdge = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    const vertex_data = VertexData.ExtractFromMesh(this);\n    const currentIndices = vertex_data.indices && !Array.isArray(vertex_data.indices) && Array.from ? Array.from(vertex_data.indices) : vertex_data.indices;\n    const positions = vertex_data.positions && !Array.isArray(vertex_data.positions) && Array.from ? Array.from(vertex_data.positions) : vertex_data.positions;\n    const uvs = vertex_data.uvs && !Array.isArray(vertex_data.uvs) && Array.from ? Array.from(vertex_data.uvs) : vertex_data.uvs;\n    const normals = vertex_data.normals && !Array.isArray(vertex_data.normals) && Array.from ? Array.from(vertex_data.normals) : vertex_data.normals;\n    if (!currentIndices || !positions) {\n      Logger.Warn(\"Couldn't increase number of vertices : VertexData must contain at least indices and positions\");\n    } else {\n      vertex_data.indices = currentIndices;\n      vertex_data.positions = positions;\n      if (uvs) {\n        vertex_data.uvs = uvs;\n      }\n      if (normals) {\n        vertex_data.normals = normals;\n      }\n      const segments = numberPerEdge + 1; //segments per current facet edge, become sides of new facets\n      const tempIndices = new Array();\n      for (let i = 0; i < segments + 1; i++) {\n        tempIndices[i] = new Array();\n      }\n      let a; //vertex index of one end of a side\n      let b; //vertex index of other end of the side\n      const deltaPosition = new Vector3(0, 0, 0);\n      const deltaNormal = new Vector3(0, 0, 0);\n      const deltaUV = new Vector2(0, 0);\n      const indices = new Array();\n      const vertexIndex = new Array();\n      const side = new Array();\n      let len;\n      let positionPtr = positions.length;\n      let uvPtr;\n      if (uvs) {\n        uvPtr = uvs.length;\n      }\n      let normalsPtr;\n      if (normals) {\n        normalsPtr = normals.length;\n      }\n      for (let i = 0; i < currentIndices.length; i += 3) {\n        vertexIndex[0] = currentIndices[i];\n        vertexIndex[1] = currentIndices[i + 1];\n        vertexIndex[2] = currentIndices[i + 2];\n        for (let j = 0; j < 3; j++) {\n          a = vertexIndex[j];\n          b = vertexIndex[(j + 1) % 3];\n          if (side[a] === undefined && side[b] === undefined) {\n            side[a] = new Array();\n            side[b] = new Array();\n          } else {\n            if (side[a] === undefined) {\n              side[a] = new Array();\n            }\n            if (side[b] === undefined) {\n              side[b] = new Array();\n            }\n          }\n          if (side[a][b] === undefined && side[b][a] === undefined) {\n            side[a][b] = [];\n            deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;\n            deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;\n            deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;\n            if (normals) {\n              deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;\n              deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;\n              deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;\n            }\n            if (uvs) {\n              deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;\n              deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;\n            }\n            side[a][b].push(a);\n            for (let k = 1; k < segments; k++) {\n              side[a][b].push(positions.length / 3);\n              positions[positionPtr++] = positions[3 * a] + k * deltaPosition.x;\n              positions[positionPtr++] = positions[3 * a + 1] + k * deltaPosition.y;\n              positions[positionPtr++] = positions[3 * a + 2] + k * deltaPosition.z;\n              if (normals) {\n                normals[normalsPtr++] = normals[3 * a] + k * deltaNormal.x;\n                normals[normalsPtr++] = normals[3 * a + 1] + k * deltaNormal.y;\n                normals[normalsPtr++] = normals[3 * a + 2] + k * deltaNormal.z;\n              }\n              if (uvs) {\n                uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;\n                uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;\n              }\n            }\n            side[a][b].push(b);\n            side[b][a] = new Array();\n            len = side[a][b].length;\n            for (let idx = 0; idx < len; idx++) {\n              side[b][a][idx] = side[a][b][len - 1 - idx];\n            }\n          }\n        }\n        //Calculate positions, normals and uvs of new internal vertices\n        tempIndices[0][0] = currentIndices[i];\n        tempIndices[1][0] = side[currentIndices[i]][currentIndices[i + 1]][1];\n        tempIndices[1][1] = side[currentIndices[i]][currentIndices[i + 2]][1];\n        for (let k = 2; k < segments; k++) {\n          tempIndices[k][0] = side[currentIndices[i]][currentIndices[i + 1]][k];\n          tempIndices[k][k] = side[currentIndices[i]][currentIndices[i + 2]][k];\n          deltaPosition.x = (positions[3 * tempIndices[k][k]] - positions[3 * tempIndices[k][0]]) / k;\n          deltaPosition.y = (positions[3 * tempIndices[k][k] + 1] - positions[3 * tempIndices[k][0] + 1]) / k;\n          deltaPosition.z = (positions[3 * tempIndices[k][k] + 2] - positions[3 * tempIndices[k][0] + 2]) / k;\n          if (normals) {\n            deltaNormal.x = (normals[3 * tempIndices[k][k]] - normals[3 * tempIndices[k][0]]) / k;\n            deltaNormal.y = (normals[3 * tempIndices[k][k] + 1] - normals[3 * tempIndices[k][0] + 1]) / k;\n            deltaNormal.z = (normals[3 * tempIndices[k][k] + 2] - normals[3 * tempIndices[k][0] + 2]) / k;\n          }\n          if (uvs) {\n            deltaUV.x = (uvs[2 * tempIndices[k][k]] - uvs[2 * tempIndices[k][0]]) / k;\n            deltaUV.y = (uvs[2 * tempIndices[k][k] + 1] - uvs[2 * tempIndices[k][0] + 1]) / k;\n          }\n          for (let j = 1; j < k; j++) {\n            tempIndices[k][j] = positions.length / 3;\n            positions[positionPtr++] = positions[3 * tempIndices[k][0]] + j * deltaPosition.x;\n            positions[positionPtr++] = positions[3 * tempIndices[k][0] + 1] + j * deltaPosition.y;\n            positions[positionPtr++] = positions[3 * tempIndices[k][0] + 2] + j * deltaPosition.z;\n            if (normals) {\n              normals[normalsPtr++] = normals[3 * tempIndices[k][0]] + j * deltaNormal.x;\n              normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 1] + j * deltaNormal.y;\n              normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 2] + j * deltaNormal.z;\n            }\n            if (uvs) {\n              uvs[uvPtr++] = uvs[2 * tempIndices[k][0]] + j * deltaUV.x;\n              uvs[uvPtr++] = uvs[2 * tempIndices[k][0] + 1] + j * deltaUV.y;\n            }\n          }\n        }\n        tempIndices[segments] = side[currentIndices[i + 1]][currentIndices[i + 2]];\n        // reform indices\n        indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);\n        for (let k = 1; k < segments; k++) {\n          let j;\n          for (j = 0; j < k; j++) {\n            indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);\n            indices.push(tempIndices[k][j], tempIndices[k + 1][j + 1], tempIndices[k][j + 1]);\n          }\n          indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);\n        }\n      }\n      vertex_data.indices = indices;\n      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n    }\n  }\n  /**\n   * Force adjacent facets to share vertices and remove any facets that have all vertices in a line\n   * This will undo any application of covertToFlatShadedMesh\n   * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n   */\n  forceSharedVertices() {\n    const vertex_data = VertexData.ExtractFromMesh(this);\n    const currentUVs = vertex_data.uvs;\n    const currentIndices = vertex_data.indices;\n    const currentPositions = vertex_data.positions;\n    const currentColors = vertex_data.colors;\n    const currentMatrixIndices = vertex_data.matricesIndices;\n    const currentMatrixWeights = vertex_data.matricesWeights;\n    const currentMatrixIndicesExtra = vertex_data.matricesIndicesExtra;\n    const currentMatrixWeightsExtra = vertex_data.matricesWeightsExtra;\n    if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {\n      Logger.Warn(\"VertexData contains empty entries\");\n    } else {\n      const positions = new Array();\n      const indices = new Array();\n      const uvs = new Array();\n      const colors = new Array();\n      const matrixIndices = new Array();\n      const matrixWeights = new Array();\n      const matrixIndicesExtra = new Array();\n      const matrixWeightsExtra = new Array();\n      let pstring = new Array(); //lists facet vertex positions (a,b,c) as string \"a|b|c\"\n      let indexPtr = 0; // pointer to next available index value\n      const uniquePositions = {}; // unique vertex positions\n      let ptr; // pointer to element in uniquePositions\n      let facet;\n      for (let i = 0; i < currentIndices.length; i += 3) {\n        facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]]; //facet vertex indices\n        pstring = new Array();\n        for (let j = 0; j < 3; j++) {\n          pstring[j] = \"\";\n          for (let k = 0; k < 3; k++) {\n            //small values make 0\n            if (Math.abs(currentPositions[3 * facet[j] + k]) < 0.00000001) {\n              currentPositions[3 * facet[j] + k] = 0;\n            }\n            pstring[j] += currentPositions[3 * facet[j] + k] + \"|\";\n          }\n        }\n        //check facet vertices to see that none are repeated\n        // do not process any facet that has a repeated vertex, ie is a line\n        if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {\n          //for each facet position check if already listed in uniquePositions\n          // if not listed add to uniquePositions and set index pointer\n          // if listed use its index in uniquePositions and new index pointer\n          for (let j = 0; j < 3; j++) {\n            ptr = uniquePositions[pstring[j]];\n            if (ptr === undefined) {\n              uniquePositions[pstring[j]] = indexPtr;\n              ptr = indexPtr++;\n              //not listed so add individual x, y, z coordinates to positions\n              for (let k = 0; k < 3; k++) {\n                positions.push(currentPositions[3 * facet[j] + k]);\n              }\n              if (currentColors !== null && currentColors !== void 0) {\n                for (let k = 0; k < 4; k++) {\n                  colors.push(currentColors[4 * facet[j] + k]);\n                }\n              }\n              if (currentUVs !== null && currentUVs !== void 0) {\n                for (let k = 0; k < 2; k++) {\n                  uvs.push(currentUVs[2 * facet[j] + k]);\n                }\n              }\n              if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {\n                for (let k = 0; k < 4; k++) {\n                  matrixIndices.push(currentMatrixIndices[4 * facet[j] + k]);\n                }\n              }\n              if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {\n                for (let k = 0; k < 4; k++) {\n                  matrixWeights.push(currentMatrixWeights[4 * facet[j] + k]);\n                }\n              }\n              if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {\n                for (let k = 0; k < 4; k++) {\n                  matrixIndicesExtra.push(currentMatrixIndicesExtra[4 * facet[j] + k]);\n                }\n              }\n              if (currentMatrixWeightsExtra !== null && currentMatrixWeightsExtra !== void 0) {\n                for (let k = 0; k < 4; k++) {\n                  matrixWeightsExtra.push(currentMatrixWeightsExtra[4 * facet[j] + k]);\n                }\n              }\n            }\n            // add new index pointer to indices array\n            indices.push(ptr);\n          }\n        }\n      }\n      const normals = new Array();\n      VertexData.ComputeNormals(positions, indices, normals);\n      //create new vertex data object and update\n      vertex_data.positions = positions;\n      vertex_data.indices = indices;\n      vertex_data.normals = normals;\n      if (currentUVs !== null && currentUVs !== void 0) {\n        vertex_data.uvs = uvs;\n      }\n      if (currentColors !== null && currentColors !== void 0) {\n        vertex_data.colors = colors;\n      }\n      if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {\n        vertex_data.matricesIndices = matrixIndices;\n      }\n      if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {\n        vertex_data.matricesWeights = matrixWeights;\n      }\n      if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {\n        vertex_data.matricesIndicesExtra = matrixIndicesExtra;\n      }\n      if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {\n        vertex_data.matricesWeightsExtra = matrixWeightsExtra;\n      }\n      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n    }\n  }\n  // Instances\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/naming-convention\n  static _instancedMeshFactory(name, mesh) {\n    throw _WarnImport(\"InstancedMesh\");\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  static _PhysicsImpostorParser(scene, physicObject, jsonObject) {\n    throw _WarnImport(\"PhysicsImpostor\");\n  }\n  /**\n   * Creates a new InstancedMesh object from the mesh model.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\n   * @param name defines the name of the new instance\n   * @returns a new InstancedMesh\n   */\n  createInstance(name) {\n    return Mesh._instancedMeshFactory(name, this);\n  }\n  /**\n   * Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.\n   * After this call, all the mesh instances have the same submeshes than the current mesh.\n   * @returns the current mesh\n   */\n  synchronizeInstances() {\n    for (let instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {\n      const instance = this.instances[instanceIndex];\n      instance._syncSubMeshes();\n    }\n    return this;\n  }\n  /**\n   * Optimization of the mesh's indices, in case a mesh has duplicated vertices.\n   * The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.\n   * This should be used together with the simplification to avoid disappearing triangles.\n   * @param successCallback an optional success callback to be called after the optimization finished.\n   * @returns the current mesh\n   */\n  optimizeIndices(successCallback) {\n    const indices = this.getIndices();\n    const positions = this.getVerticesData(VertexBuffer.PositionKind);\n    if (!positions || !indices) {\n      return this;\n    }\n    const vectorPositions = new Array();\n    for (let pos = 0; pos < positions.length; pos = pos + 3) {\n      vectorPositions.push(Vector3.FromArray(positions, pos));\n    }\n    const dupes = new Array();\n    AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, iteration => {\n      const realPos = vectorPositions.length - 1 - iteration;\n      const testedPosition = vectorPositions[realPos];\n      for (let j = 0; j < realPos; ++j) {\n        const againstPosition = vectorPositions[j];\n        if (testedPosition.equals(againstPosition)) {\n          dupes[realPos] = j;\n          break;\n        }\n      }\n    }, () => {\n      for (let i = 0; i < indices.length; ++i) {\n        indices[i] = dupes[indices[i]] || indices[i];\n      }\n      //indices are now reordered\n      const originalSubMeshes = this.subMeshes.slice(0);\n      this.setIndices(indices);\n      this.subMeshes = originalSubMeshes;\n      if (successCallback) {\n        successCallback(this);\n      }\n    });\n    return this;\n  }\n  /**\n   * Serialize current mesh\n   * @param serializationObject defines the object which will receive the serialization data\n   */\n  serialize() {\n    let serializationObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    serializationObject.name = this.name;\n    serializationObject.id = this.id;\n    serializationObject.uniqueId = this.uniqueId;\n    serializationObject.type = this.getClassName();\n    if (Tags && Tags.HasTags(this)) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n    serializationObject.position = this.position.asArray();\n    if (this.rotationQuaternion) {\n      serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();\n    } else if (this.rotation) {\n      serializationObject.rotation = this.rotation.asArray();\n    }\n    serializationObject.scaling = this.scaling.asArray();\n    if (this._postMultiplyPivotMatrix) {\n      serializationObject.pivotMatrix = this.getPivotMatrix().asArray();\n    } else {\n      serializationObject.localMatrix = this.getPivotMatrix().asArray();\n    }\n    serializationObject.isEnabled = this.isEnabled(false);\n    serializationObject.isVisible = this.isVisible;\n    serializationObject.infiniteDistance = this.infiniteDistance;\n    serializationObject.pickable = this.isPickable;\n    serializationObject.receiveShadows = this.receiveShadows;\n    serializationObject.billboardMode = this.billboardMode;\n    serializationObject.visibility = this.visibility;\n    serializationObject.checkCollisions = this.checkCollisions;\n    serializationObject.isBlocker = this.isBlocker;\n    serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation;\n    // Parent\n    if (this.parent) {\n      this.parent._serializeAsParent(serializationObject);\n    }\n    // Geometry\n    serializationObject.isUnIndexed = this.isUnIndexed;\n    const geometry = this._geometry;\n    if (geometry && this.subMeshes) {\n      serializationObject.geometryUniqueId = geometry.uniqueId;\n      serializationObject.geometryId = geometry.id;\n      // SubMeshes\n      serializationObject.subMeshes = [];\n      for (let subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {\n        const subMesh = this.subMeshes[subIndex];\n        serializationObject.subMeshes.push({\n          materialIndex: subMesh.materialIndex,\n          verticesStart: subMesh.verticesStart,\n          verticesCount: subMesh.verticesCount,\n          indexStart: subMesh.indexStart,\n          indexCount: subMesh.indexCount\n        });\n      }\n    }\n    // Material\n    if (this.material) {\n      if (!this.material.doNotSerialize) {\n        serializationObject.materialUniqueId = this.material.uniqueId;\n        serializationObject.materialId = this.material.id; // back compat\n      }\n    } else {\n      this.material = null;\n      serializationObject.materialUniqueId = this._scene.defaultMaterial.uniqueId;\n      serializationObject.materialId = this._scene.defaultMaterial.id; // back compat\n    }\n    // Morph targets\n    if (this.morphTargetManager) {\n      serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;\n    }\n    // Skeleton\n    if (this.skeleton) {\n      serializationObject.skeletonId = this.skeleton.id;\n      serializationObject.numBoneInfluencers = this.numBoneInfluencers;\n    }\n    // Physics\n    //TODO implement correct serialization for physics impostors.\n    if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\n      const impostor = this.getPhysicsImpostor();\n      if (impostor) {\n        serializationObject.physicsMass = impostor.getParam(\"mass\");\n        serializationObject.physicsFriction = impostor.getParam(\"friction\");\n        serializationObject.physicsRestitution = impostor.getParam(\"mass\");\n        serializationObject.physicsImpostor = impostor.type;\n      }\n    }\n    // Metadata\n    if (this.metadata) {\n      serializationObject.metadata = this.metadata;\n    }\n    // Instances\n    serializationObject.instances = [];\n    for (let index = 0; index < this.instances.length; index++) {\n      const instance = this.instances[index];\n      if (instance.doNotSerialize) {\n        continue;\n      }\n      const serializationInstance = {\n        name: instance.name,\n        id: instance.id,\n        isEnabled: instance.isEnabled(false),\n        isVisible: instance.isVisible,\n        isPickable: instance.isPickable,\n        checkCollisions: instance.checkCollisions,\n        position: instance.position.asArray(),\n        scaling: instance.scaling.asArray()\n      };\n      if (instance.parent) {\n        instance.parent._serializeAsParent(serializationInstance);\n      }\n      if (instance.rotationQuaternion) {\n        serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();\n      } else if (instance.rotation) {\n        serializationInstance.rotation = instance.rotation.asArray();\n      }\n      // Physics\n      //TODO implement correct serialization for physics impostors.\n      if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\n        const impostor = instance.getPhysicsImpostor();\n        if (impostor) {\n          serializationInstance.physicsMass = impostor.getParam(\"mass\");\n          serializationInstance.physicsFriction = impostor.getParam(\"friction\");\n          serializationInstance.physicsRestitution = impostor.getParam(\"mass\");\n          serializationInstance.physicsImpostor = impostor.type;\n        }\n      }\n      // Metadata\n      if (instance.metadata) {\n        serializationInstance.metadata = instance.metadata;\n      }\n      // Action Manager\n      if (instance.actionManager) {\n        serializationInstance.actions = instance.actionManager.serialize(instance.name);\n      }\n      serializationObject.instances.push(serializationInstance);\n      // Animations\n      SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);\n      serializationInstance.ranges = instance.serializeAnimationRanges();\n    }\n    // Thin instances\n    if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {\n      serializationObject.thinInstances = {\n        instancesCount: this._thinInstanceDataStorage.instancesCount,\n        matrixData: Array.from(this._thinInstanceDataStorage.matrixData),\n        matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,\n        enablePicking: this.thinInstanceEnablePicking\n      };\n      if (this._userThinInstanceBuffersStorage) {\n        const userThinInstance = {\n          data: {},\n          sizes: {},\n          strides: {}\n        };\n        for (const kind in this._userThinInstanceBuffersStorage.data) {\n          userThinInstance.data[kind] = Array.from(this._userThinInstanceBuffersStorage.data[kind]);\n          userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];\n          userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];\n        }\n        serializationObject.thinInstances.userThinInstance = userThinInstance;\n      }\n    }\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    serializationObject.ranges = this.serializeAnimationRanges();\n    // Layer mask\n    serializationObject.layerMask = this.layerMask;\n    // Alpha\n    serializationObject.alphaIndex = this.alphaIndex;\n    serializationObject.hasVertexAlpha = this.hasVertexAlpha;\n    // Overlay\n    serializationObject.overlayAlpha = this.overlayAlpha;\n    serializationObject.overlayColor = this.overlayColor.asArray();\n    serializationObject.renderOverlay = this.renderOverlay;\n    // Fog\n    serializationObject.applyFog = this.applyFog;\n    // Action Manager\n    if (this.actionManager) {\n      serializationObject.actions = this.actionManager.serialize(this.name);\n    }\n    return serializationObject;\n  }\n  /** @internal */\n  _syncGeometryWithMorphTargetManager() {\n    if (!this.geometry) {\n      return;\n    }\n    this._markSubMeshesAsAttributesDirty();\n    const morphTargetManager = this._internalAbstractMeshDataInfo._morphTargetManager;\n    if (morphTargetManager && morphTargetManager.vertexCount) {\n      if (morphTargetManager.vertexCount !== this.getTotalVertices()) {\n        Logger.Error(\"Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.\");\n        this.morphTargetManager = null;\n        return;\n      }\n      if (morphTargetManager.isUsingTextureForTargets) {\n        return;\n      }\n      for (let index = 0; index < morphTargetManager.numInfluencers; index++) {\n        const morphTarget = morphTargetManager.getActiveTarget(index);\n        const positions = morphTarget.getPositions();\n        if (!positions) {\n          Logger.Error(\"Invalid morph target. Target must have positions.\");\n          return;\n        }\n        this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);\n        const normals = morphTarget.getNormals();\n        if (normals) {\n          this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);\n        }\n        const tangents = morphTarget.getTangents();\n        if (tangents) {\n          this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);\n        }\n        const uvs = morphTarget.getUVs();\n        if (uvs) {\n          this.geometry.setVerticesData(VertexBuffer.UVKind + \"_\" + index, uvs, false, 2);\n        }\n      }\n    } else {\n      let index = 0;\n      // Positions\n      while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + index)) {\n        this.geometry.removeVerticesData(VertexBuffer.PositionKind + index);\n        if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + index)) {\n          this.geometry.removeVerticesData(VertexBuffer.NormalKind + index);\n        }\n        if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + index)) {\n          this.geometry.removeVerticesData(VertexBuffer.TangentKind + index);\n        }\n        if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + index)) {\n          this.geometry.removeVerticesData(VertexBuffer.UVKind + \"_\" + index);\n        }\n        index++;\n      }\n    }\n  }\n  /**\n   * Returns a new Mesh object parsed from the source provided.\n   * @param parsedMesh is the source\n   * @param scene defines the hosting scene\n   * @param rootUrl is the root URL to prefix the `delayLoadingFile` property with\n   * @returns a new Mesh\n   */\n  static Parse(parsedMesh, scene, rootUrl) {\n    let mesh;\n    if (parsedMesh.type && parsedMesh.type === \"LinesMesh\") {\n      mesh = Mesh._LinesMeshParser(parsedMesh, scene);\n    } else if (parsedMesh.type && parsedMesh.type === \"GroundMesh\") {\n      mesh = Mesh._GroundMeshParser(parsedMesh, scene);\n    } else if (parsedMesh.type && parsedMesh.type === \"GoldbergMesh\") {\n      mesh = Mesh._GoldbergMeshParser(parsedMesh, scene);\n    } else {\n      mesh = new Mesh(parsedMesh.name, scene);\n    }\n    mesh.id = parsedMesh.id;\n    mesh._waitingParsedUniqueId = parsedMesh.uniqueId;\n    if (Tags) {\n      Tags.AddTagsTo(mesh, parsedMesh.tags);\n    }\n    mesh.position = Vector3.FromArray(parsedMesh.position);\n    if (parsedMesh.metadata !== undefined) {\n      mesh.metadata = parsedMesh.metadata;\n    }\n    if (parsedMesh.rotationQuaternion) {\n      mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);\n    } else if (parsedMesh.rotation) {\n      mesh.rotation = Vector3.FromArray(parsedMesh.rotation);\n    }\n    mesh.scaling = Vector3.FromArray(parsedMesh.scaling);\n    if (parsedMesh.localMatrix) {\n      mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));\n    } else if (parsedMesh.pivotMatrix) {\n      mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));\n    }\n    mesh.setEnabled(parsedMesh.isEnabled);\n    mesh.isVisible = parsedMesh.isVisible;\n    mesh.infiniteDistance = parsedMesh.infiniteDistance;\n    mesh.showBoundingBox = parsedMesh.showBoundingBox;\n    mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;\n    if (parsedMesh.applyFog !== undefined) {\n      mesh.applyFog = parsedMesh.applyFog;\n    }\n    if (parsedMesh.pickable !== undefined) {\n      mesh.isPickable = parsedMesh.pickable;\n    }\n    if (parsedMesh.alphaIndex !== undefined) {\n      mesh.alphaIndex = parsedMesh.alphaIndex;\n    }\n    mesh.receiveShadows = parsedMesh.receiveShadows;\n    if (parsedMesh.billboardMode !== undefined) {\n      mesh.billboardMode = parsedMesh.billboardMode;\n    }\n    if (parsedMesh.visibility !== undefined) {\n      mesh.visibility = parsedMesh.visibility;\n    }\n    mesh.checkCollisions = parsedMesh.checkCollisions;\n    mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;\n    if (parsedMesh.isBlocker !== undefined) {\n      mesh.isBlocker = parsedMesh.isBlocker;\n    }\n    mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;\n    // freezeWorldMatrix\n    if (parsedMesh.freezeWorldMatrix) {\n      mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;\n    }\n    // Parent\n    if (parsedMesh.parentId !== undefined) {\n      mesh._waitingParentId = parsedMesh.parentId;\n    }\n    if (parsedMesh.parentInstanceIndex !== undefined) {\n      mesh._waitingParentInstanceIndex = parsedMesh.parentInstanceIndex;\n    }\n    // Actions\n    if (parsedMesh.actions !== undefined) {\n      mesh._waitingData.actions = parsedMesh.actions;\n    }\n    // Overlay\n    if (parsedMesh.overlayAlpha !== undefined) {\n      mesh.overlayAlpha = parsedMesh.overlayAlpha;\n    }\n    if (parsedMesh.overlayColor !== undefined) {\n      mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);\n    }\n    if (parsedMesh.renderOverlay !== undefined) {\n      mesh.renderOverlay = parsedMesh.renderOverlay;\n    }\n    // Geometry\n    mesh.isUnIndexed = !!parsedMesh.isUnIndexed;\n    mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;\n    if (parsedMesh.delayLoadingFile) {\n      mesh.delayLoadState = 4;\n      mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;\n      mesh.buildBoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));\n      if (parsedMesh._binaryInfo) {\n        mesh._binaryInfo = parsedMesh._binaryInfo;\n      }\n      mesh._delayInfo = [];\n      if (parsedMesh.hasUVs) {\n        mesh._delayInfo.push(VertexBuffer.UVKind);\n      }\n      if (parsedMesh.hasUVs2) {\n        mesh._delayInfo.push(VertexBuffer.UV2Kind);\n      }\n      if (parsedMesh.hasUVs3) {\n        mesh._delayInfo.push(VertexBuffer.UV3Kind);\n      }\n      if (parsedMesh.hasUVs4) {\n        mesh._delayInfo.push(VertexBuffer.UV4Kind);\n      }\n      if (parsedMesh.hasUVs5) {\n        mesh._delayInfo.push(VertexBuffer.UV5Kind);\n      }\n      if (parsedMesh.hasUVs6) {\n        mesh._delayInfo.push(VertexBuffer.UV6Kind);\n      }\n      if (parsedMesh.hasColors) {\n        mesh._delayInfo.push(VertexBuffer.ColorKind);\n      }\n      if (parsedMesh.hasMatricesIndices) {\n        mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);\n      }\n      if (parsedMesh.hasMatricesWeights) {\n        mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);\n      }\n      mesh._delayLoadingFunction = Geometry._ImportGeometry;\n      if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {\n        mesh._checkDelayState();\n      }\n    } else {\n      Geometry._ImportGeometry(parsedMesh, mesh);\n    }\n    // Material\n    if (parsedMesh.materialUniqueId) {\n      mesh._waitingMaterialId = parsedMesh.materialUniqueId;\n    } else if (parsedMesh.materialId) {\n      mesh._waitingMaterialId = parsedMesh.materialId;\n    }\n    // Morph targets\n    if (parsedMesh.morphTargetManagerId > -1) {\n      mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);\n    }\n    // Skeleton\n    if (parsedMesh.skeletonId !== undefined && parsedMesh.skeletonId !== null) {\n      mesh.skeleton = scene.getLastSkeletonById(parsedMesh.skeletonId);\n      if (parsedMesh.numBoneInfluencers) {\n        mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;\n      }\n    }\n    // Animations\n    if (parsedMesh.animations) {\n      for (let animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {\n        const parsedAnimation = parsedMesh.animations[animationIndex];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          mesh.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n      Node.ParseAnimationRanges(mesh, parsedMesh, scene);\n    }\n    if (parsedMesh.autoAnimate) {\n      scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1.0);\n    }\n    // Layer Mask\n    if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {\n      mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));\n    } else {\n      mesh.layerMask = 0x0fffffff;\n    }\n    // Physics\n    if (parsedMesh.physicsImpostor) {\n      Mesh._PhysicsImpostorParser(scene, mesh, parsedMesh);\n    }\n    // Levels\n    if (parsedMesh.lodMeshIds) {\n      mesh._waitingData.lods = {\n        ids: parsedMesh.lodMeshIds,\n        distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,\n        coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null\n      };\n    }\n    // Instances\n    if (parsedMesh.instances) {\n      for (let index = 0; index < parsedMesh.instances.length; index++) {\n        const parsedInstance = parsedMesh.instances[index];\n        const instance = mesh.createInstance(parsedInstance.name);\n        if (parsedInstance.id) {\n          instance.id = parsedInstance.id;\n        }\n        if (Tags) {\n          if (parsedInstance.tags) {\n            Tags.AddTagsTo(instance, parsedInstance.tags);\n          } else {\n            Tags.AddTagsTo(instance, parsedMesh.tags);\n          }\n        }\n        instance.position = Vector3.FromArray(parsedInstance.position);\n        if (parsedInstance.metadata !== undefined) {\n          instance.metadata = parsedInstance.metadata;\n        }\n        if (parsedInstance.parentId !== undefined) {\n          instance._waitingParentId = parsedInstance.parentId;\n        }\n        if (parsedInstance.parentInstanceIndex !== undefined) {\n          instance._waitingParentInstanceIndex = parsedInstance.parentInstanceIndex;\n        }\n        if (parsedInstance.isEnabled !== undefined && parsedInstance.isEnabled !== null) {\n          instance.setEnabled(parsedInstance.isEnabled);\n        }\n        if (parsedInstance.isVisible !== undefined && parsedInstance.isVisible !== null) {\n          instance.isVisible = parsedInstance.isVisible;\n        }\n        if (parsedInstance.isPickable !== undefined && parsedInstance.isPickable !== null) {\n          instance.isPickable = parsedInstance.isPickable;\n        }\n        if (parsedInstance.rotationQuaternion) {\n          instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);\n        } else if (parsedInstance.rotation) {\n          instance.rotation = Vector3.FromArray(parsedInstance.rotation);\n        }\n        instance.scaling = Vector3.FromArray(parsedInstance.scaling);\n        if (parsedInstance.checkCollisions != undefined && parsedInstance.checkCollisions != null) {\n          instance.checkCollisions = parsedInstance.checkCollisions;\n        }\n        if (parsedInstance.pickable != undefined && parsedInstance.pickable != null) {\n          instance.isPickable = parsedInstance.pickable;\n        }\n        if (parsedInstance.showBoundingBox != undefined && parsedInstance.showBoundingBox != null) {\n          instance.showBoundingBox = parsedInstance.showBoundingBox;\n        }\n        if (parsedInstance.showSubMeshesBoundingBox != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\n          instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;\n        }\n        if (parsedInstance.alphaIndex != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\n          instance.alphaIndex = parsedInstance.alphaIndex;\n        }\n        // Physics\n        if (parsedInstance.physicsImpostor) {\n          Mesh._PhysicsImpostorParser(scene, instance, parsedInstance);\n        }\n        // Actions\n        if (parsedInstance.actions !== undefined) {\n          instance._waitingData.actions = parsedInstance.actions;\n        }\n        // Animation\n        if (parsedInstance.animations) {\n          for (let animationIndex = 0; animationIndex < parsedInstance.animations.length; animationIndex++) {\n            const parsedAnimation = parsedInstance.animations[animationIndex];\n            const internalClass = GetClass(\"BABYLON.Animation\");\n            if (internalClass) {\n              instance.animations.push(internalClass.Parse(parsedAnimation));\n            }\n          }\n          Node.ParseAnimationRanges(instance, parsedInstance, scene);\n          if (parsedInstance.autoAnimate) {\n            scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1.0);\n          }\n        }\n      }\n    }\n    // Thin instances\n    if (parsedMesh.thinInstances) {\n      const thinInstances = parsedMesh.thinInstances;\n      mesh.thinInstanceEnablePicking = !!thinInstances.enablePicking;\n      if (thinInstances.matrixData) {\n        mesh.thinInstanceSetBuffer(\"matrix\", new Float32Array(thinInstances.matrixData), 16, false);\n        mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\n        mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;\n      } else {\n        mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\n      }\n      if (parsedMesh.thinInstances.userThinInstance) {\n        const userThinInstance = parsedMesh.thinInstances.userThinInstance;\n        for (const kind in userThinInstance.data) {\n          mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);\n          mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];\n        }\n      }\n    }\n    return mesh;\n  }\n  // Skeletons\n  /**\n   * Prepare internal position array for software CPU skinning\n   * @returns original positions used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh\n   */\n  setPositionsForCPUSkinning() {\n    const internalDataInfo = this._internalMeshDataInfo;\n    if (!internalDataInfo._sourcePositions) {\n      const source = this.getVerticesData(VertexBuffer.PositionKind);\n      if (!source) {\n        return internalDataInfo._sourcePositions;\n      }\n      internalDataInfo._sourcePositions = new Float32Array(source);\n      if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\n        this.setVerticesData(VertexBuffer.PositionKind, source, true);\n      }\n    }\n    return internalDataInfo._sourcePositions;\n  }\n  /**\n   * Prepare internal normal array for software CPU skinning\n   * @returns original normals used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh.\n   */\n  setNormalsForCPUSkinning() {\n    const internalDataInfo = this._internalMeshDataInfo;\n    if (!internalDataInfo._sourceNormals) {\n      const source = this.getVerticesData(VertexBuffer.NormalKind);\n      if (!source) {\n        return internalDataInfo._sourceNormals;\n      }\n      internalDataInfo._sourceNormals = new Float32Array(source);\n      if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\n        this.setVerticesData(VertexBuffer.NormalKind, source, true);\n      }\n    }\n    return internalDataInfo._sourceNormals;\n  }\n  /**\n   * Updates the vertex buffer by applying transformation from the bones\n   * @param skeleton defines the skeleton to apply to current mesh\n   * @returns the current mesh\n   */\n  applySkeleton(skeleton) {\n    if (!this.geometry) {\n      return this;\n    }\n    if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {\n      return this;\n    }\n    this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();\n    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      return this;\n    }\n    if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      return this;\n    }\n    if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      return this;\n    }\n    const hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);\n    const internalDataInfo = this._internalMeshDataInfo;\n    if (!internalDataInfo._sourcePositions) {\n      const submeshes = this.subMeshes.slice();\n      this.setPositionsForCPUSkinning();\n      this.subMeshes = submeshes;\n    }\n    if (hasNormals && !internalDataInfo._sourceNormals) {\n      this.setNormalsForCPUSkinning();\n    }\n    // positionsData checks for not being Float32Array will only pass at most once\n    let positionsData = this.getVerticesData(VertexBuffer.PositionKind);\n    if (!positionsData) {\n      return this;\n    }\n    if (!(positionsData instanceof Float32Array)) {\n      positionsData = new Float32Array(positionsData);\n    }\n    // normalsData checks for not being Float32Array will only pass at most once\n    let normalsData = this.getVerticesData(VertexBuffer.NormalKind);\n    if (hasNormals) {\n      if (!normalsData) {\n        return this;\n      }\n      if (!(normalsData instanceof Float32Array)) {\n        normalsData = new Float32Array(normalsData);\n      }\n    }\n    const matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    const matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n    if (!matricesWeightsData || !matricesIndicesData) {\n      return this;\n    }\n    const needExtras = this.numBoneInfluencers > 4;\n    const matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n    const matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n    const skeletonMatrices = skeleton.getTransformMatrices(this);\n    const tempVector3 = Vector3.Zero();\n    const finalMatrix = new Matrix();\n    const tempMatrix = new Matrix();\n    let matWeightIdx = 0;\n    let inf;\n    for (let index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {\n      let weight;\n      for (inf = 0; inf < 4; inf++) {\n        weight = matricesWeightsData[matWeightIdx + inf];\n        if (weight > 0) {\n          Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\n          finalMatrix.addToSelf(tempMatrix);\n        }\n      }\n      if (needExtras) {\n        for (inf = 0; inf < 4; inf++) {\n          weight = matricesWeightsExtraData[matWeightIdx + inf];\n          if (weight > 0) {\n            Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\n            finalMatrix.addToSelf(tempMatrix);\n          }\n        }\n      }\n      Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);\n      tempVector3.toArray(positionsData, index);\n      if (hasNormals) {\n        Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);\n        tempVector3.toArray(normalsData, index);\n      }\n      finalMatrix.reset();\n    }\n    this.updateVerticesData(VertexBuffer.PositionKind, positionsData);\n    if (hasNormals) {\n      this.updateVerticesData(VertexBuffer.NormalKind, normalsData);\n    }\n    return this;\n  }\n  // Tools\n  /**\n   * Returns an object containing a min and max Vector3 which are the minimum and maximum vectors of each mesh bounding box from the passed array, in the world coordinates\n   * @param meshes defines the list of meshes to scan\n   * @returns an object `{min:` Vector3`, max:` Vector3`}`\n   */\n  static MinMax(meshes) {\n    let minVector = null;\n    let maxVector = null;\n    meshes.forEach(function (mesh) {\n      const boundingInfo = mesh.getBoundingInfo();\n      const boundingBox = boundingInfo.boundingBox;\n      if (!minVector || !maxVector) {\n        minVector = boundingBox.minimumWorld;\n        maxVector = boundingBox.maximumWorld;\n      } else {\n        minVector.minimizeInPlace(boundingBox.minimumWorld);\n        maxVector.maximizeInPlace(boundingBox.maximumWorld);\n      }\n    });\n    if (!minVector || !maxVector) {\n      return {\n        min: Vector3.Zero(),\n        max: Vector3.Zero()\n      };\n    }\n    return {\n      min: minVector,\n      max: maxVector\n    };\n  }\n  /**\n   * Returns the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array\n   * @param meshesOrMinMaxVector could be an array of meshes or a `{min:` Vector3`, max:` Vector3`}` object\n   * @returns a vector3\n   */\n  static Center(meshesOrMinMaxVector) {\n    const minMaxVector = meshesOrMinMaxVector instanceof Array ? Mesh.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;\n    return Vector3.Center(minMaxVector.min, minMaxVector.max);\n  }\n  /**\n   * Merge the array of meshes into a single mesh for performance reasons.\n   * @param meshes array of meshes with the vertices to merge. Entries cannot be empty meshes.\n   * @param disposeSource when true (default), dispose of the vertices from the source meshes.\n   * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true.\n   * @param meshSubclass (optional) can be set to a Mesh where the merged vertices will be inserted.\n   * @param subdivideWithSubMeshes when true (false default), subdivide mesh into subMeshes.\n   * @param multiMultiMaterials when true (false default), subdivide mesh into subMeshes with multiple materials, ignores subdivideWithSubMeshes.\n   * @returns a new mesh\n   */\n  static MergeMeshes(meshes) {\n    let disposeSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let allow32BitsIndices = arguments.length > 2 ? arguments[2] : undefined;\n    let meshSubclass = arguments.length > 3 ? arguments[3] : undefined;\n    let subdivideWithSubMeshes = arguments.length > 4 ? arguments[4] : undefined;\n    let multiMultiMaterials = arguments.length > 5 ? arguments[5] : undefined;\n    return runCoroutineSync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, false));\n  }\n  /**\n   * Merge the array of meshes into a single mesh for performance reasons.\n   * @param meshes array of meshes with the vertices to merge. Entries cannot be empty meshes.\n   * @param disposeSource when true (default), dispose of the vertices from the source meshes.\n   * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true.\n   * @param meshSubclass (optional) can be set to a Mesh where the merged vertices will be inserted.\n   * @param subdivideWithSubMeshes when true (false default), subdivide mesh into subMeshes.\n   * @param multiMultiMaterials when true (false default), subdivide mesh into subMeshes with multiple materials, ignores subdivideWithSubMeshes.\n   * @returns a new mesh\n   */\n  static MergeMeshesAsync(meshes) {\n    let disposeSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let allow32BitsIndices = arguments.length > 2 ? arguments[2] : undefined;\n    let meshSubclass = arguments.length > 3 ? arguments[3] : undefined;\n    let subdivideWithSubMeshes = arguments.length > 4 ? arguments[4] : undefined;\n    let multiMultiMaterials = arguments.length > 5 ? arguments[5] : undefined;\n    return runCoroutineAsync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, true), createYieldingScheduler());\n  }\n  static _MergeMeshesCoroutine(meshes) {\n    let disposeSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let allow32BitsIndices = arguments.length > 2 ? arguments[2] : undefined;\n    let meshSubclass = arguments.length > 3 ? arguments[3] : undefined;\n    let subdivideWithSubMeshes = arguments.length > 4 ? arguments[4] : undefined;\n    let multiMultiMaterials = arguments.length > 5 ? arguments[5] : undefined;\n    let isAsync = arguments.length > 6 ? arguments[6] : undefined;\n    return function* () {\n      // Remove any null/undefined entries from the mesh array\n      meshes = meshes.filter(Boolean);\n      if (meshes.length === 0) {\n        return null;\n      }\n      let index;\n      if (!allow32BitsIndices) {\n        let totalVertices = 0;\n        // Counting vertices\n        for (index = 0; index < meshes.length; index++) {\n          totalVertices += meshes[index].getTotalVertices();\n          if (totalVertices >= 65536) {\n            Logger.Warn(\"Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices\");\n            return null;\n          }\n        }\n      }\n      if (multiMultiMaterials) {\n        subdivideWithSubMeshes = false;\n      }\n      const materialArray = new Array();\n      const materialIndexArray = new Array();\n      // Merge\n      const indiceArray = new Array();\n      const currentOverrideMaterialSideOrientation = meshes[0].overrideMaterialSideOrientation;\n      for (index = 0; index < meshes.length; index++) {\n        const mesh = meshes[index];\n        if (mesh.isAnInstance) {\n          Logger.Warn(\"Cannot merge instance meshes.\");\n          return null;\n        }\n        if (currentOverrideMaterialSideOrientation !== mesh.overrideMaterialSideOrientation) {\n          Logger.Warn(\"Cannot merge meshes with different overrideMaterialSideOrientation values.\");\n          return null;\n        }\n        if (subdivideWithSubMeshes) {\n          indiceArray.push(mesh.getTotalIndices());\n        }\n        if (multiMultiMaterials) {\n          if (mesh.material) {\n            const material = mesh.material;\n            if (material instanceof MultiMaterial) {\n              for (let matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {\n                if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {\n                  materialArray.push(material.subMaterials[matIndex]);\n                }\n              }\n              for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));\n                indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n              }\n            } else {\n              if (materialArray.indexOf(material) < 0) {\n                materialArray.push(material);\n              }\n              for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                materialIndexArray.push(materialArray.indexOf(material));\n                indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n              }\n            }\n          } else {\n            for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n              materialIndexArray.push(0);\n              indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n            }\n          }\n        }\n      }\n      const source = meshes[0];\n      const getVertexDataFromMesh = mesh => {\n        const wm = mesh.computeWorldMatrix(true);\n        const vertexData = VertexData.ExtractFromMesh(mesh, false, false);\n        return {\n          vertexData,\n          transform: wm\n        };\n      };\n      const {\n        vertexData: sourceVertexData,\n        transform: sourceTransform\n      } = getVertexDataFromMesh(source);\n      if (isAsync) {\n        yield;\n      }\n      const meshVertexDatas = new Array(meshes.length - 1);\n      for (let i = 1; i < meshes.length; i++) {\n        meshVertexDatas[i - 1] = getVertexDataFromMesh(meshes[i]);\n        if (isAsync) {\n          yield;\n        }\n      }\n      const mergeCoroutine = sourceVertexData._mergeCoroutine(sourceTransform, meshVertexDatas, allow32BitsIndices, isAsync, !disposeSource);\n      let mergeCoroutineStep = mergeCoroutine.next();\n      while (!mergeCoroutineStep.done) {\n        if (isAsync) {\n          yield;\n        }\n        mergeCoroutineStep = mergeCoroutine.next();\n      }\n      const vertexData = mergeCoroutineStep.value;\n      if (!meshSubclass) {\n        meshSubclass = new Mesh(source.name + \"_merged\", source.getScene());\n      }\n      const applyToCoroutine = vertexData._applyToCoroutine(meshSubclass, undefined, isAsync);\n      let applyToCoroutineStep = applyToCoroutine.next();\n      while (!applyToCoroutineStep.done) {\n        if (isAsync) {\n          yield;\n        }\n        applyToCoroutineStep = applyToCoroutine.next();\n      }\n      // Setting properties\n      meshSubclass.checkCollisions = source.checkCollisions;\n      meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation;\n      // Cleaning\n      if (disposeSource) {\n        for (index = 0; index < meshes.length; index++) {\n          meshes[index].dispose();\n        }\n      }\n      // Subdivide\n      if (subdivideWithSubMeshes || multiMultiMaterials) {\n        //-- removal of global submesh\n        meshSubclass.releaseSubMeshes();\n        index = 0;\n        let offset = 0;\n        //-- apply subdivision according to index table\n        while (index < indiceArray.length) {\n          SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass, undefined, false);\n          offset += indiceArray[index];\n          index++;\n        }\n        for (const subMesh of meshSubclass.subMeshes) {\n          subMesh.refreshBoundingInfo();\n        }\n        meshSubclass.computeWorldMatrix(true);\n      }\n      if (multiMultiMaterials) {\n        const newMultiMaterial = new MultiMaterial(source.name + \"_merged\", source.getScene());\n        newMultiMaterial.subMaterials = materialArray;\n        for (let subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {\n          meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];\n        }\n        meshSubclass.material = newMultiMaterial;\n      } else {\n        meshSubclass.material = source.material;\n      }\n      return meshSubclass;\n    }();\n  }\n  /**\n   * @internal\n   */\n  addInstance(instance) {\n    instance._indexInSourceMeshInstanceArray = this.instances.length;\n    this.instances.push(instance);\n  }\n  /**\n   * @internal\n   */\n  removeInstance(instance) {\n    // Remove from mesh\n    const index = instance._indexInSourceMeshInstanceArray;\n    if (index != -1) {\n      if (index !== this.instances.length - 1) {\n        const last = this.instances[this.instances.length - 1];\n        this.instances[index] = last;\n        last._indexInSourceMeshInstanceArray = index;\n      }\n      instance._indexInSourceMeshInstanceArray = -1;\n      this.instances.pop();\n    }\n  }\n  /** @internal */\n  _shouldConvertRHS() {\n    return this.overrideMaterialSideOrientation === Material.CounterClockWiseSideOrientation;\n  }\n}\n// Consts\n/**\n * Mesh side orientation : usually the external or front surface\n */\nMesh.FRONTSIDE = VertexData.FRONTSIDE;\n/**\n * Mesh side orientation : usually the internal or back surface\n */\nMesh.BACKSIDE = VertexData.BACKSIDE;\n/**\n * Mesh side orientation : both internal and external or front and back surfaces\n */\nMesh.DOUBLESIDE = VertexData.DOUBLESIDE;\n/**\n * Mesh side orientation : by default, `FRONTSIDE`\n */\nMesh.DEFAULTSIDE = VertexData.DEFAULTSIDE;\n/**\n * Mesh cap setting : no cap\n */\nMesh.NO_CAP = 0;\n/**\n * Mesh cap setting : one cap at the beginning of the mesh\n */\nMesh.CAP_START = 1;\n/**\n * Mesh cap setting : one cap at the end of the mesh\n */\nMesh.CAP_END = 2;\n/**\n * Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh\n */\nMesh.CAP_ALL = 3;\n/**\n * Mesh pattern setting : no flip or rotate\n */\nMesh.NO_FLIP = 0;\n/**\n * Mesh pattern setting : flip (reflect in y axis) alternate tiles on each row or column\n */\nMesh.FLIP_TILE = 1;\n/**\n * Mesh pattern setting : rotate (180degs) alternate tiles on each row or column\n */\nMesh.ROTATE_TILE = 2;\n/**\n * Mesh pattern setting : flip (reflect in y axis) all tiles on alternate rows\n */\nMesh.FLIP_ROW = 3;\n/**\n * Mesh pattern setting : rotate (180degs) all tiles on alternate rows\n */\nMesh.ROTATE_ROW = 4;\n/**\n * Mesh pattern setting : flip and rotate alternate tiles on each row or column\n */\nMesh.FLIP_N_ROTATE_TILE = 5;\n/**\n * Mesh pattern setting : rotate pattern and rotate\n */\nMesh.FLIP_N_ROTATE_ROW = 6;\n/**\n * Mesh tile positioning : part tiles same on left/right or top/bottom\n */\nMesh.CENTER = 0;\n/**\n * Mesh tile positioning : part tiles on left\n */\nMesh.LEFT = 1;\n/**\n * Mesh tile positioning : part tiles on right\n */\nMesh.RIGHT = 2;\n/**\n * Mesh tile positioning : part tiles on top\n */\nMesh.TOP = 3;\n/**\n * Mesh tile positioning : part tiles on bottom\n */\nMesh.BOTTOM = 4;\n/**\n * Indicates that the instanced meshes should be sorted from back to front before rendering if their material is transparent\n */\nMesh.INSTANCEDMESH_SORT_TRANSPARENT = false;\n// Statics\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nMesh._GroundMeshParser = (parsedMesh, scene) => {\n  throw _WarnImport(\"GroundMesh\");\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nMesh._GoldbergMeshParser = (parsedMesh, scene) => {\n  throw _WarnImport(\"GoldbergMesh\");\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nMesh._LinesMeshParser = (parsedMesh, scene) => {\n  throw _WarnImport(\"LinesMesh\");\n};\nRegisterClass(\"BABYLON.Mesh\", Mesh);\n/**\n * @internal\n */\nMesh.prototype.setMaterialByID = function (id) {\n  return this.setMaterialById(id);\n};\nMesh.CreateDisc = Mesh.CreateDisc || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateBox = Mesh.CreateBox || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateSphere = Mesh.CreateSphere || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateCylinder = Mesh.CreateCylinder || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateTorusKnot = Mesh.CreateTorusKnot || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateTorus = Mesh.CreateTorus || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreatePlane = Mesh.CreatePlane || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateGround = Mesh.CreateGround || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateTiledGround = Mesh.CreateTiledGround || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateGroundFromHeightMap = Mesh.CreateGroundFromHeightMap || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateTube = Mesh.CreateTube || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreatePolyhedron = Mesh.CreatePolyhedron || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateIcoSphere = Mesh.CreateIcoSphere || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateDecal = Mesh.CreateDecal || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.CreateCapsule = Mesh.CreateCapsule || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});\nMesh.ExtendToGoldberg = Mesh.ExtendToGoldberg || (() => {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n});"],"names":["_InstanceDataStorage","constructor","this","visibleInstances","batchCache","_InstancesBatch","batchCacheReplacementModeInFrozenMode","instancesBufferSize","mustReturn","Array","renderSelf","hardwareInstancedRendering","_ThinInstanceDataStorage","instancesCount","matrixBuffer","previousMatrixBuffer","matrixBufferSize","matrixData","boundingVectors","worldMatrices","_InternalMeshDataInfo","_areNormalsFrozen","_source","meshMap","_preActivateId","_LODLevels","_useLODScreenCoverage","_effectiveMaterial","_forcedInstanceCount","Mesh","static","orientation","FRONTSIDE","useLODScreenCoverage","_internalMeshDataInfo","value","_sortLODLevels","computeBonesUsingShaders","_internalAbstractMeshDataInfo","_computeBonesUsingShaders","_sourcePositions","setVerticesData","_sourceNormals","_markSubMeshesAsAttributesDirty","onBeforeRenderObservable","_onBeforeRenderObservable","onBeforeBindObservable","_onBeforeBindObservable","onAfterRenderObservable","_onAfterRenderObservable","onBetweenPassObservable","_onBetweenPassObservable","onBeforeDrawObservable","_onBeforeDrawObservable","onBeforeDraw","callback","_onBeforeDrawObserver","remove","add","hasInstances","instances","length","hasThinInstances","_a","_thinInstanceDataStorage","forcedInstanceCount","count","source","cloneMeshMap","isUnIndexed","_unIndexed","worldMatrixInstancedBuffer","_instanceDataStorage","instancesData","previousWorldMatrixInstancedBuffer","instancesPreviousData","manualUpdateOfWorldMatrixInstancedBuffer","manualUpdate","manualUpdateOfPreviousWorldMatrixInstancedBuffer","previousManualUpdate","forceWorldMatrixInstancedBufferUpdate","forceMatrixUpdates","name","scene","arguments","undefined","parent","doNotCloneChildren","clonePhysicsImpostor","super","delayLoadState","_creationDataStorage","_geometry","_shouldGenerateFlatShading","_originalBuilderSideOrientation","DEFAULTSIDE","overrideMaterialSideOrientation","ignoreCameraMaxZ","getScene","_onBeforeDraw","isInstance","world","effectiveMaterial","_uniformBuffer","transferToEffect","bindOnlyWorldMatrix","applyToMesh","useClonedMeshMap","uniqueId","_ranges","ranges","Object","prototype","hasOwnProperty","call","createAnimationRange","from","to","metadata","clone","_internalMetadata","setEnabled","isEnabled","setPivotMatrix","getPivotMatrix","id","material","directDescendants","getDescendants","index","child","morphTargetManager","getPhysicsEngine","physicsEngine","getPluginVersion","impostor","getImpostorForPhysicsObject","physicsImpostor","physicsBody","particleSystems","system","emitter","skeleton","refreshBoundingInfo","computeWorldMatrix","getEngine","getCaps","instancedArrays","_onMeshReadyObserverAdded","observer","unregisterOnNextCall","isReady","onMeshReadyObservable","notifyObservers","_checkReadinessObserver","_scene","onClonedObservable","instantiateHierarchy","newParent","options","onNewNodeCreated","instance","getTotalVertices","doNotInstantiate","createInstance","position","scaling","rotationQuaternion","rotation","getChildTransformNodes","getClassName","sourceMesh","newSourcedMesh","_isMesh","toString","fullDetails","ret","_waitingParentId","animations","i","ib","getIndices","vb","getVerticesData","_unBindEffect","hasLODLevels","getLODLevels","sortingOrderFactor","sort","a","b","distanceOrScreenCoverage","addLODLevel","mesh","_masterMesh","level","push","getLODLevelAtDistance","distance","internalDataInfo","removeLODLevel","splice","getLOD","camera","boundingSphere","bSphere","getBoundingInfo","distanceToCamera","mode","minZ","centerWorld","subtract","globalPosition","compareValue","compareSign","screenArea","meshArea","radiusWorld","Math","PI","onLODLevelSelection","_checkDelayState","_preActivate","_updateSubMeshesBoundingInfo","worldMatrixFromCache","geometry","kind","copyWhenShared","forceCopy","bypassInstanceData","_b","data","_userInstancedBuffersStorage","vertexBuffers","getFloatData","meshes","getVertexBuffer","isVerticesDataPresent","_delayInfo","indexOf","isVertexBufferUpdatable","buffer","isUpdatable","getVerticesDataKinds","result","forEach","kinds","getTotalIndices","isBlocked","completeCheck","forceInstanceSupport","_c","_d","_e","_f","subMeshes","engine","mat","defaultMaterial","_storeEffectOnSubMeshes","subMesh","getMaterial","isReadyForSubMesh","currentRenderPassId","light","lightSources","generators","getShadowGenerators","iterator","values","key","next","done","generator","getShadowMap","renderList","renderPassId","needAlphaBlendingForMesh","lod","areNormalsFrozen","freezeNormals","unfreezeNormals","overridenInstanceCount","sceneRenderId","getRenderId","_preActivateForIntermediateRendering","renderId","intermediateDefaultRenderId","_registerInstanceForRenderId","defaultRenderId","selfDefaultRenderId","_renderId","previousRenderId","isFrozen","_afterComputeWorldMatrix","doNotSyncBoundingInfo","thinInstanceRefreshBoundingInfo","_postActivate","edgesShareWithInstances","edgesRenderer","_renderingGroup","_edgesRenderers","pushNoDuplicate","customInstances","getWorldMatrix","applySkeleton","applyMorph","hasBoundingInfo","isLocked","bias","boundingBias","_refreshBoundingInfo","_getPositionData","_createGlobalSubMesh","force","totalVertices","totalIndices","needToRecreate","submesh","indexStart","indexCount","verticesStart","verticesCount","releaseSubMeshes","subdivide","subdivisionSize","offset","synchronizeInstances","updatable","stride","vertexData","set","removeVerticesData","markVerticesDataAsUpdatable","setVerticesBuffer","disposeExistingBuffer","updateVerticesData","updateExtends","makeItUnique","makeGeometryUnique","updateMeshPositions","positionFunction","computeNormals","positions","indices","normals","oldGeometry","copy","releaseForMesh","setIndices","updateIndices","gpuMemoryOnly","toLeftHanded","_bind","effect","fillMode","allowInstancedRendering","indexToBind","isUsingTextureForTargets","_getLinesIndexBuffer","getIndexBuffer","vertexArrayObjects","_draw","getVertexBuffers","drawArraysType","drawElementsType","_linesIndexCount","registerBeforeRender","func","unregisterBeforeRender","removeCallback","registerAfterRender","unregisterAfterRender","_getInstancesRenderList","subMeshId","isReplacementMode","previousBatch","isInIntermediateRendering","_isInIntermediateRendering","onlyForInstances","_onlyForInstancesIntermediate","_onlyForInstances","isVisible","currentRenderId","_renderWithInstances","batch","_id","visibleInstanceCount","instanceStorage","currentInstancesBufferSize","instancesBuffer","instancesPreviousBuffer","bufferSize","Float32Array","needsPreviousWorldMatrices","needUpdateBuffer","masterMeshPreviousWorldMatrix","copyToArray","copyFrom","INSTANCEDMESH_SORT_TRANSPARENT","activeCamera","getRenderingMesh","cameraPosition","instanceIndex","instanceMesh","_distanceToCamera","m1","m2","matrix","_previousWorldMatrix","dispose","strides","sizes","vertexArrayObject","createVertexBuffer","_invalidateInstanceVertexArrayObject","updateDirectly","_processInstancedBuffers","_activeIndices","addCount","_currentDrawContext","useInstancing","unbindInstanceAttributes","_renderWithThinInstances","previousMatrixData","_thinInstanceCreateMatrixBuffer","_processRendering","renderingMesh","instanceCount","visibleInstancesForSubMesh","_rebuild","_freeze","_unFreeze","render","enableAlphaMode","effectiveMeshReplacement","_isActiveIntermediate","_isActive","_checkOcclusionQuery","_occlusionDataStorage","forceRenderingWhenOccluded","oldCameraMaxZ","oldCamera","maxZ","updateTransformMatrix","getMesh","_actAsRegularMesh","instanceDataStorage","_wasPreviouslyReady","getEffect","drawWrapper","setAlphaMode","alphaMode","_drawWrapper","_getDrawWrapper","step","_beforeRenderingMeshStage","action","effectiveMesh","sideOrientation","backFaceCulling","mainDeterminant","_getWorldMatrixDeterminant","reverse","_preBind","forceDepthWrite","setDepthWrite","forcePointsCloud","forceWireframe","bindForSubMesh","bind","separateCullingPass","setState","zOffset","cullBackFaces","stencil","zOffsetUnits","unbind","_afterRenderingMeshStage","performancePriority","cleanMatrixWeights","_normalizeSkinWeightsAndExtra","_normalizeSkinFourWeights","matricesWeights","numWeights","t","recip","matricesWeightsExtra","validateSkinning","skinned","valid","report","numberNotSorted","missingWeights","maxUsedWeights","numberNotNormalized","numInfluences","usedWeightCounts","lastWeight","usedWeights","d","tolerance","abs","numBones","bones","matricesIndices","matricesIndicesExtra","numBadBoneIndices","load","_queueLoad","addPendingData","getBinaryData","delayLoadingFile","ArrayBuffer","_delayLoadingFunction","JSON","parse","_syncSubMeshes","removePendingData","offlineProvider","isInFrustum","frustumPlanes","setMaterialById","materials","multiMaterials","getAnimatables","results","bakeTransformIntoVertices","transform","submeshes","_resetPointsArrayCache","temp","toArray","normalize","determinant","flipFaces","bakeCurrentTransformIntoVertices","bakeIndependentlyOfChildren","resetLocalMatrix","_positions","_generatePointsArray","doNotRecurse","disposeMaterialAndTextures","clear","abstractMesh","_disposeInstanceSpecificData","_disposeThinInstanceSpecificData","applyDisplacementMap","url","minHeight","maxHeight","onSuccess","uvOffset","uvScale","forceUpdate","img","heightMapWidth","width","heightMapHeight","height","context","createCanvas","getContext","drawImage","getImageData","applyDisplacementMapFromBuffer","uvs","normal","uv","pos","x","y","gradient","scaleInPlace","convertToFlatShadedMesh","vbs","newdata","kindIndex","updatableNormals","vertexBuffer","getData","previousSubmeshes","slice","vertexIndex","getStrideSize","flipNormalGeneration","useRightHandedSystem","p1","p2","p3","p1p2","p3p2","localIndex","z","submeshIndex","previousOne","materialIndex","convertToUnIndexedMesh","flipNormals","vertex_data","increaseVertices","numberPerEdge","currentIndices","isArray","segments","tempIndices","deltaPosition","deltaNormal","deltaUV","side","len","uvPtr","normalsPtr","positionPtr","j","k","idx","forceSharedVertices","currentUVs","currentPositions","currentColors","colors","currentMatrixIndices","currentMatrixWeights","currentMatrixIndicesExtra","currentMatrixWeightsExtra","matrixIndices","matrixWeights","matrixIndicesExtra","matrixWeightsExtra","pstring","indexPtr","uniquePositions","ptr","facet","physicObject","jsonObject","_instancedMeshFactory","optimizeIndices","successCallback","vectorPositions","dupes","iteration","realPos","testedPosition","againstPosition","equals","originalSubMeshes","serialize","serializationObject","type","tags","asArray","_postMultiplyPivotMatrix","pivotMatrix","localMatrix","infiniteDistance","pickable","isPickable","receiveShadows","billboardMode","visibility","checkCollisions","isBlocker","_serializeAsParent","geometryUniqueId","geometryId","subIndex","doNotSerialize","materialUniqueId","materialId","morphTargetManagerId","skeletonId","numBoneInfluencers","_getComponent","getPhysicsImpostor","physicsMass","getParam","physicsFriction","physicsRestitution","serializationInstance","actionManager","actions","serializeAnimationRanges","thinInstances","enablePicking","thinInstanceEnablePicking","_userThinInstanceBuffersStorage","userThinInstance","layerMask","alphaIndex","hasVertexAlpha","overlayAlpha","overlayColor","renderOverlay","applyFog","_syncGeometryWithMorphTargetManager","_morphTargetManager","vertexCount","numInfluencers","morphTarget","getActiveTarget","getPositions","getNormals","tangents","getTangents","getUVs","parsedMesh","rootUrl","_LinesMeshParser","_GroundMeshParser","_GoldbergMeshParser","_waitingParsedUniqueId","setPreTransformMatrix","showBoundingBox","showSubMeshesBoundingBox","useFlatShading","freezeWorldMatrix","_waitingData","parentId","parentInstanceIndex","_waitingParentInstanceIndex","buildBoundingInfo","boundingBoxMinimum","boundingBoxMaximum","_binaryInfo","hasUVs","hasUVs2","hasUVs3","hasUVs4","hasUVs5","hasUVs6","hasColors","hasMatricesIndices","hasMatricesWeights","_waitingMaterialId","getMorphTargetManagerById","getLastSkeletonById","animationIndex","parsedAnimation","internalClass","Parse","N","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","isNaN","parseInt","_PhysicsImpostorParser","lodMeshIds","lods","ids","distances","lodDistances","coverages","lodCoverages","parsedInstance","thinInstanceSetBuffer","setPositionsForCPUSkinning","setNormalsForCPUSkinning","_softwareSkinningFrameId","getFrameId","hasNormals","positionsData","normalsData","matricesIndicesData","matricesWeightsData","needExtras","matricesIndicesExtraData","matricesWeightsExtraData","skeletonMatrices","getTransformMatrices","tempVector3","finalMatrix","tempMatrix","inf","matWeightIdx","weight","floor","addToSelf","reset","minVector","maxVector","boundingBox","minimizeInPlace","minimumWorld","maximizeInPlace","maximumWorld","min","max","meshesOrMinMaxVector","minMaxVector","MinMax","disposeSource","allow32BitsIndices","meshSubclass","subdivideWithSubMeshes","multiMultiMaterials","_MergeMeshesCoroutine","isAsync","filter","Boolean","materialArray","materialIndexArray","indiceArray","currentOverrideMaterialSideOrientation","isAnInstance","matIndex","subMaterials","getVertexDataFromMesh","wm","sourceVertexData","sourceTransform","meshVertexDatas","mergeCoroutine","_mergeCoroutine","mergeCoroutineStep","applyToCoroutine","_applyToCoroutine","applyToCoroutineStep","newMultiMaterial","addInstance","_indexInSourceMeshInstanceArray","removeInstance","last","pop","_shouldConvertRHS","BACKSIDE","DOUBLESIDE","NO_CAP","CAP_START","CAP_END","CAP_ALL","NO_FLIP","FLIP_TILE","ROTATE_TILE","FLIP_ROW","ROTATE_ROW","FLIP_N_ROTATE_TILE","FLIP_N_ROTATE_ROW","CENTER","LEFT","RIGHT","TOP","BOTTOM","setMaterialByID","CreateDisc","Error","CreateBox","CreateSphere","CreateCylinder","CreateTorusKnot","CreateTorus","CreatePlane","CreateGround","CreateTiledGround","CreateGroundFromHeightMap","CreateTube","CreatePolyhedron","CreateIcoSphere","CreateDecal","CreateCapsule","ExtendToGoldberg"],"sourceRoot":""}